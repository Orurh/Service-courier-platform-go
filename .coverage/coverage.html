
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>app: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">course-go-avito-Orurh/internal/app/container.go (47.2%)</option>
				
				<option value="file1">course-go-avito-Orurh/internal/app/helpers.go (100.0%)</option>
				
				<option value="file2">course-go-avito-Orurh/internal/app/kafka_orders.go (0.0%)</option>
				
				<option value="file3">course-go-avito-Orurh/internal/app/logger.go (100.0%)</option>
				
				<option value="file4">course-go-avito-Orurh/internal/app/runner.go (74.5%)</option>
				
				<option value="file5">course-go-avito-Orurh/internal/app/worker_runner.go (0.0%)</option>
				
				<option value="file6">course-go-avito-Orurh/internal/config/config.go (89.4%)</option>
				
				<option value="file7">course-go-avito-Orurh/internal/domain/status.go (100.0%)</option>
				
				<option value="file8">course-go-avito-Orurh/internal/gateway/orders/order.go (100.0%)</option>
				
				<option value="file9">course-go-avito-Orurh/internal/http/handlers/contracts.go (100.0%)</option>
				
				<option value="file10">course-go-avito-Orurh/internal/http/handlers/courier.go (100.0%)</option>
				
				<option value="file11">course-go-avito-Orurh/internal/http/handlers/courier_convert.go (100.0%)</option>
				
				<option value="file12">course-go-avito-Orurh/internal/http/handlers/delivery.go (100.0%)</option>
				
				<option value="file13">course-go-avito-Orurh/internal/http/handlers/delivery_convert.go (100.0%)</option>
				
				<option value="file14">course-go-avito-Orurh/internal/http/handlers/handlers.go (100.0%)</option>
				
				<option value="file15">course-go-avito-Orurh/internal/http/handlers/helpers.go (78.4%)</option>
				
				<option value="file16">course-go-avito-Orurh/internal/http/middleware/observability.go (17.6%)</option>
				
				<option value="file17">course-go-avito-Orurh/internal/http/router/router.go (100.0%)</option>
				
				<option value="file18">course-go-avito-Orurh/internal/logx/adapter.go (54.5%)</option>
				
				<option value="file19">course-go-avito-Orurh/internal/logx/contracts.go (83.3%)</option>
				
				<option value="file20">course-go-avito-Orurh/internal/logx/nop.go (33.3%)</option>
				
				<option value="file21">course-go-avito-Orurh/internal/proto/orders.pb.go (21.6%)</option>
				
				<option value="file22">course-go-avito-Orurh/internal/proto/orders_grpc.pb.go (0.0%)</option>
				
				<option value="file23">course-go-avito-Orurh/internal/repository/courier.go (88.4%)</option>
				
				<option value="file24">course-go-avito-Orurh/internal/repository/db.go (100.0%)</option>
				
				<option value="file25">course-go-avito-Orurh/internal/repository/delivery.go (80.4%)</option>
				
				<option value="file26">course-go-avito-Orurh/internal/repository/errors.go (100.0%)</option>
				
				<option value="file27">course-go-avito-Orurh/internal/service/courier/courier.go (100.0%)</option>
				
				<option value="file28">course-go-avito-Orurh/internal/service/delivery/factory.go (100.0%)</option>
				
				<option value="file29">course-go-avito-Orurh/internal/service/delivery/usecase.go (100.0%)</option>
				
				<option value="file30">course-go-avito-Orurh/internal/service/orders/factory.go (100.0%)</option>
				
				<option value="file31">course-go-avito-Orurh/internal/service/orders/processor.go (85.2%)</option>
				
				<option value="file32">course-go-avito-Orurh/internal/testutil/testlog.go (73.7%)</option>
				
				<option value="file33">course-go-avito-Orurh/internal/transport/kafka/consumer.go (49.1%)</option>
				
				<option value="file34">course-go-avito-Orurh/internal/transport/kafka/dto.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package app

import (
        "context"
        "fmt"
        "net/http"
        "strings"
        "time"

        "github.com/jackc/pgx/v5/pgxpool"
        "go.uber.org/dig"
        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials/insecure"

        "course-go-avito-Orurh/internal/config"
        ordersgw "course-go-avito-Orurh/internal/gateway/orders"
        "course-go-avito-Orurh/internal/http/handlers"
        "course-go-avito-Orurh/internal/http/router"
        "course-go-avito-Orurh/internal/logx"
        ordersproto "course-go-avito-Orurh/internal/proto"
        "course-go-avito-Orurh/internal/repository"
        "course-go-avito-Orurh/internal/service/courier"
        "course-go-avito-Orurh/internal/service/delivery"
        "course-go-avito-Orurh/internal/service/orders"
        "course-go-avito-Orurh/internal/transport/kafka"
)

func MustBuildWorkerContainer(ctx context.Context) *dig.Container <span class="cov0" title="0">{
        return NewContainerBuilder().MustBuildWorker(ctx)
}</span>

// ContainerBuilder is a dig container builder.
type ContainerBuilder struct {
        dbConnect func(context.Context, logx.Logger, string, int, time.Duration) (*pgxpool.Pool, error)

        logFatalf func(string, ...any)
}

// NewContainerBuilder returns a new dig container builder
func NewContainerBuilder() *ContainerBuilder <span class="cov4" title="7">{
        return &amp;ContainerBuilder{
                dbConnect: connectDbWithRetry,
                logFatalf: func(format string, args ...any) </span><span class="cov0" title="0">{ panic(fmt.Sprintf(format, args...))</span> },
        }
}

// WithDBConnect sets the database connection function
func (b *ContainerBuilder) WithDBConnect(
        fn func(context.Context, logx.Logger, string, int, time.Duration) (*pgxpool.Pool, error),
) *ContainerBuilder <span class="cov4" title="6">{
        if fn != nil </span><span class="cov4" title="6">{
                b.dbConnect = fn
        }</span>
        <span class="cov4" title="6">return b</span>
}

// WithLogFatalf sets the log.Fatalf function
func (b *ContainerBuilder) WithLogFatalf(fn func(string, ...any)) *ContainerBuilder <span class="cov2" title="2">{
        if fn != nil </span><span class="cov2" title="2">{
                b.logFatalf = fn
        }</span>
        <span class="cov2" title="2">return b</span>
}

// MustBuild builds and returns a new dig container
func (b *ContainerBuilder) MustBuild(ctx context.Context) *dig.Container <span class="cov2" title="3">{
        container, err := b.build(ctx)
        if err != nil </span><span class="cov0" title="0">{
                b.logFatalf("failed to build container: %v", err)
        }</span>
        <span class="cov2" title="3">return container</span>
}

// build builds and returns a new dig container
func (b *ContainerBuilder) build(ctx context.Context) (*dig.Container, error) <span class="cov4" title="7">{
        container := dig.New()

        if err := registerCore(container, ctx); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("core: %w", err)
        }</span>
        <span class="cov4" title="7">if err := registerDb(container, b.dbConnect); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("DB: %w", err)
        }</span>
        <span class="cov4" title="7">if err := registerDomainServices(container); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("service: %w", err)
        }</span>
        <span class="cov4" title="7">if err := registerHTTP(container); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("http: %w", err)
        }</span>
        <span class="cov4" title="7">return container, nil</span>
}

func (b *ContainerBuilder) MustBuildWorker(ctx context.Context) *dig.Container <span class="cov0" title="0">{
        container, err := b.buildWorker(ctx)
        if err != nil </span><span class="cov0" title="0">{
                b.logFatalf("failed to build worker container: %v", err)
        }</span>
        <span class="cov0" title="0">return container</span>
}

func (b *ContainerBuilder) buildWorker(ctx context.Context) (*dig.Container, error) <span class="cov0" title="0">{
        container := dig.New()

        if err := registerCore(container, ctx); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("core: %w", err)
        }</span>
        <span class="cov0" title="0">if err := registerDb(container, b.dbConnect); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("DB: %w", err)
        }</span>
        <span class="cov0" title="0">if err := registerDomainServices(container); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("service: %w", err)
        }</span>
        <span class="cov0" title="0">if err := registerWorker(container); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("worker: %w", err)
        }</span>
        <span class="cov0" title="0">return container, nil</span>
}

// MustBuildContainer builds and returns a new dig container
func MustBuildContainer(ctx context.Context) *dig.Container <span class="cov1" title="1">{
        return NewContainerBuilder().MustBuild(ctx)
}</span>

func provideAll(container *dig.Container, providers ...any) error <span class="cov7" title="40">{
        for _, provider := range providers </span><span class="cov10" title="168">{
                if err := container.Provide(provider); err != nil </span><span class="cov2" title="2">{
                        return fmt.Errorf("provide %T: %w", provider, err)
                }</span>
        }
        <span class="cov7" title="38">return nil</span>
}

func registerCore(container *dig.Container, ctx context.Context) error <span class="cov4" title="9">{
        return provideAll(container,
                func() context.Context </span><span class="cov4" title="7">{ return ctx }</span>,
                NewLogger,
                config.Load,
                func(cfg *config.Config) autoReleaseInterval <span class="cov2" title="2">{
                        return autoReleaseInterval(cfg.Delivery.AutoReleaseInterval)
                }</span>,
        )
}

func registerDb(
        container *dig.Container,
        dbConnect func(context.Context, logx.Logger, string, int, time.Duration) (*pgxpool.Pool, error),
) error <span class="cov4" title="9">{
        providerDB := func(ctx context.Context, cfg *config.Config, logger logx.Logger) (*pgxpool.Pool, error) </span><span class="cov4" title="7">{
                return dbConnect(ctx, logger, cfg.DB.DSN(), 10, time.Second)
        }</span>
        <span class="cov4" title="9">return provideAll(container, providerDB)</span>
}

func registerDomainServices(container *dig.Container) error <span class="cov4" title="9">{
        return provideAll(container,
                repository.NewCourierRepo,
                repository.NewDeliveryRepo,

                func() time.Duration </span><span class="cov2" title="2">{ return 3 * time.Second }</span>,
                func(repo *repository.CourierRepo, timeout time.Duration) *courier.Service <span class="cov2" title="2">{
                        return courier.NewService(repo, timeout)
                }</span>,
                delivery.NewTimeFactory,
                func(
                        repo *repository.DeliveryRepo,
                        timeout time.Duration,
                        factory delivery.TimeFactory,
                        logger logx.Logger,
                ) *delivery.Service <span class="cov2" title="2">{
                        return delivery.NewDeliveryService(repo, factory, timeout, logger)
                }</span>,
        )
}

func registerWorker(container *dig.Container) error <span class="cov0" title="0">{
        return provideAll(container,
                provideOrdersGateway,
                orders.NewProcessor,
                makeOrdersKafka,

                func(cfg *config.Config, h kafka.HandleFunc, logger logx.Logger) (*kafka.Consumer, error) </span><span class="cov0" title="0">{
                        c, err := kafka.NewConsumer(logger, cfg.Kafka.Brokers, cfg.Kafka.GroupID, cfg.Kafka.Topic, h)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">if c == nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("kafka config is missing: worker requires KAFKA_BROKERS/KAFKA_GROUP_ID/KAFKA_TOPIC")
                        }</span>
                        <span class="cov0" title="0">return c, nil</span>
                },
        )
}

func registerHTTP(container *dig.Container) error <span class="cov4" title="9">{
        serverProvider := func(cfg *config.Config, mux http.Handler) *http.Server </span><span class="cov2" title="2">{
                return &amp;http.Server{
                        Addr:              fmt.Sprintf(":%d", cfg.Port),
                        Handler:           mux,
                        ReadHeaderTimeout: 5 * time.Second,
                        ReadTimeout:       15 * time.Second,
                        WriteTimeout:      15 * time.Second,
                        IdleTimeout:       60 * time.Second,
                }
        }</span>
        <span class="cov4" title="9">return provideAll(container,
                handlers.New,
                handlers.NewCourierUsecase,
                handlers.NewCourierHandler,
                handlers.NewDeliveryUsecase,
                handlers.NewDeliveryHandler,
                router.New,
                serverProvider,
        )</span>
}

type ordersConnCloser func() error

func provideOrdersGateway(ctx context.Context, cfg *config.Config) (*ordersgw.GRPCGateway, ordersConnCloser, error) <span class="cov0" title="0">{
        addr := strings.TrimSpace(cfg.OrderService)
        if addr == "" </span><span class="cov0" title="0">{
                return nil, nil, nil
        }</span>
        <span class="cov0" title="0">conn, err := grpc.NewClient(addr, grpc.WithTransportCredentials(insecure.NewCredentials()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("provideOrdersGateway grpc: %w", err)
        }</span>
        <span class="cov0" title="0">client := ordersproto.NewOrdersServiceClient(conn)
        gw := ordersgw.NewGRPCGateway(client)
        return gw, func() error </span><span class="cov0" title="0">{ return conn.Close() }</span>, nil
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package app

import (
        "context"
        "fmt"
        "time"

        "github.com/jackc/pgx/v5/pgxpool"

        "course-go-avito-Orurh/internal/logx"
        "course-go-avito-Orurh/internal/repository"
)

var newPool = repository.NewPool

func connectDbWithRetry(ctx context.Context, logger logx.Logger, dsn string, retries int, delay time.Duration) (*pgxpool.Pool, error) <span class="cov7" title="4">{
        var lastErr error
        const attemptTimeout = 3 * time.Second
        for i := 1; i &lt;= retries; i++ </span><span class="cov10" title="6">{
                retriesCtx, cancel := context.WithTimeout(ctx, attemptTimeout)
                pool, err := newPool(retriesCtx, dsn)
                cancel()
                if err == nil </span><span class="cov4" title="2">{
                        logger.Info("db connected", logx.Int("attempt", i))
                        return pool, nil
                }</span>
                <span class="cov7" title="4">lastErr = err
                logger.Warn("db connect failed", logx.Int("attempt", i), logx.Int("retries", retries), logx.Any("err", err))
                if i &lt; retries </span><span class="cov6" title="3">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov1" title="1">
                                return nil, ctx.Err()</span>
                        case &lt;-time.After(delay):<span class="cov4" title="2"></span>
                        }
                }
        }
        <span class="cov1" title="1">return nil, fmt.Errorf("db connect failed after %d attempts: %w", retries, lastErr)</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package app

import (
        "context"
        "time"

        ordersgw "course-go-avito-Orurh/internal/gateway/orders"
        "course-go-avito-Orurh/internal/service/orders"
        "course-go-avito-Orurh/internal/transport/kafka"
)

func makeOrdersKafka(p *orders.Processor, gw *ordersgw.GRPCGateway) kafka.HandleFunc <span class="cov0" title="0">{
        return func(ctx context.Context, event orders.Event) error </span><span class="cov0" title="0">{
                if gw == nil </span><span class="cov0" title="0">{
                        return p.Handle(ctx, event)
                }</span>

                <span class="cov0" title="0">gwCtx, cancel := context.WithTimeout(ctx, 2*time.Second)
                defer cancel()

                ord, err := gw.GetByID(gwCtx, event.OrderID)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if ord == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">event.Status = ord.Status
                event.CreatedAt = ord.CreatedAt
                return p.Handle(ctx, event)</span>
        }
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package app

import (
        "log/slog"
        "os"

        "course-go-avito-Orurh/internal/logx"
)

func NewLogger() logx.Logger <span class="cov10" title="7">{
        base := slog.New(slog.NewJSONHandler(os.Stdout, &amp;slog.HandlerOptions{
                Level: slog.LevelInfo,
        }))
        return logx.NewSlogAdapter(base)
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package app

import (
        "context"
        "errors"
        "net/http"
        "time"

        "github.com/jackc/pgx/v5/pgxpool"
        "go.uber.org/dig"

        "course-go-avito-Orurh/internal/logx"
        "course-go-avito-Orurh/internal/service/delivery"
)

type autoReleaseInterval time.Duration

const (
        shutdownTimeout = 15 * time.Second
)

// Runner runs the HTTP server
type Runner struct{ runFn func(*dig.Container) error }

// NewRunner returns a new Runner
func NewRunner() *Runner <span class="cov2" title="2">{
        return &amp;Runner{runFn: run}
}</span>

// MustRun starts the HTTP server using the provided DI container
func (r *Runner) MustRun(container *dig.Container) <span class="cov4" title="4">{
        err := r.runFn(container)
        if err == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov4" title="4">if container == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov4" title="4">invErr := container.Invoke(func(logger logx.Logger) </span><span class="cov4" title="4">{
                switch </span>{
                case errors.Is(err, context.Canceled):<span class="cov2" title="2">
                        logger.Info("shutdown requested, exiting")</span>
                case errors.Is(err, context.DeadlineExceeded):<span class="cov2" title="2">
                        logger.Info("startup aborted: startup timeout exceeded")</span>
                default:<span class="cov0" title="0">
                        logger.Error("run error", logx.Any("err", err))</span>
                }
        })
        <span class="cov4" title="4">if invErr != nil </span><span class="cov0" title="0">{
                return
        }</span>
}

func run(container *dig.Container) error <span class="cov2" title="2">{
        return container.Invoke(appRun)
}</span>

type appDeps struct {
        dig.In

        Server              *http.Server
        AppCtx              context.Context
        Pool                *pgxpool.Pool
        Logger              logx.Logger
        DeliveryService     *delivery.Service
        AutoReleaseInterval autoReleaseInterval

        OrdersCloser ordersConnCloser `optional:"true"`
}

func appRun(d appDeps) error <span class="cov2" title="2">{
        defer closeResources(d.Pool, d.Server, d.Logger, d.OrdersCloser)
        startAutoReleaseLoop(d.AppCtx, d.Logger, d.DeliveryService, time.Duration(d.AutoReleaseInterval))
        serverErrCh := startServer(d.Server, d.Logger)
        err := waitForShutdown(d.AppCtx, d.Logger, serverErrCh)
        d.Logger.Info("shut down service-courier")
        gracefulShutdown(d.Server, d.Logger, shutdownTimeout)
        return err
}</span>

func startAutoReleaseLoop(ctx context.Context, logger logx.Logger, deliveryService *delivery.Service, interval time.Duration) <span class="cov4" title="4">{
        go func() </span><span class="cov4" title="4">{
                ticker := time.NewTicker(interval)
                defer ticker.Stop()
                for </span><span class="cov10" title="24">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov4" title="4">
                                return</span>
                        case &lt;-ticker.C:<span class="cov9" title="20">
                                if err := deliveryService.ReleaseExpired(ctx); err != nil </span><span class="cov0" title="0">{
                                        logger.Error("auto-release failed", logx.Any("err", err))
                                }</span>
                        }
                }
        }()
}

func startServer(server *http.Server, logger logx.Logger) &lt;-chan error <span class="cov2" title="2">{
        ch := make(chan error, 1)
        go func() </span><span class="cov2" title="2">{
                logger.Info("service-courier listening", logx.String("addr", server.Addr))
                err := server.ListenAndServe()
                if err != nil &amp;&amp; !errors.Is(err, http.ErrServerClosed) </span><span class="cov0" title="0">{
                        ch &lt;- err
                        return
                }</span>
                <span class="cov2" title="2">ch &lt;- nil</span>
        }()
        <span class="cov2" title="2">return ch</span>
}

func waitForShutdown(ctx context.Context, logger logx.Logger, serverErrCh &lt;-chan error) error <span class="cov2" title="2">{
        select </span>{
        case &lt;-ctx.Done():<span class="cov2" title="2">
                return ctx.Err()</span>
        case err := &lt;-serverErrCh:<span class="cov0" title="0">
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("server stopped", logx.Any("err", err))
                }</span>
                <span class="cov0" title="0">return err</span>
        }
}

func gracefulShutdown(srv *http.Server, logger logx.Logger, timeout time.Duration) <span class="cov4" title="4">{
        shutdownCtx, cancel := context.WithTimeout(context.Background(), timeout)
        defer cancel()
        if err := srv.Shutdown(shutdownCtx); err != nil </span><span class="cov0" title="0">{
                logger.Error("graceful shutdown error", logx.Any("err", err))
        }</span>
}

func closeResources(pool *pgxpool.Pool, server *http.Server, logger logx.Logger, ordersCloser ordersConnCloser) <span class="cov2" title="2">{
        if server != nil </span><span class="cov2" title="2">{
                if err := server.Close(); err != nil &amp;&amp; !errors.Is(err, http.ErrServerClosed) </span><span class="cov0" title="0">{
                        logger.Error("server close error", logx.Any("err", err))
                }</span>
        }
        <span class="cov2" title="2">if ordersCloser != nil </span><span class="cov2" title="2">{
                if err := ordersCloser(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("orders close error", logx.Any("err", err))
                }</span>
        }
        <span class="cov2" title="2">if pool != nil </span><span class="cov0" title="0">{
                pool.Close()
        }</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package app

import (
        "context"
        "errors"
        "fmt"

        "github.com/jackc/pgx/v5/pgxpool"
        "go.uber.org/dig"

        "course-go-avito-Orurh/internal/logx"
        "course-go-avito-Orurh/internal/transport/kafka"
)

type WorkerRunner struct {
        runFn func(*dig.Container) error
}

func NewWorkerRunner() *WorkerRunner <span class="cov0" title="0">{
        return &amp;WorkerRunner{runFn: runWorker}
}</span>

func (r *WorkerRunner) MustRun(container *dig.Container) <span class="cov0" title="0">{
        err := r.runFn(container)
        if err == nil || errors.Is(err, context.Canceled) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">panic(err)</span>
}

func runWorker(container *dig.Container) error <span class="cov0" title="0">{
        return container.Invoke(workerRun)
}</span>

func workerRun(
        ctx context.Context,
        pool *pgxpool.Pool,
        logger logx.Logger,
        consumer *kafka.Consumer,
        ordersCloser ordersConnCloser,
) error <span class="cov0" title="0">{
        if consumer == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("kafka consumer is nil: worker container misconfigured")
        }</span>
        <span class="cov0" title="0">defer closeWorker(pool, logger, consumer, ordersCloser)

        logger.Info("service-courier-worker started")
        return consumer.Run(ctx)</span>
}

func closeWorker(pool *pgxpool.Pool, logger logx.Logger, kafkaConsumer *kafka.Consumer, ordersCloser ordersConnCloser) <span class="cov0" title="0">{
        if kafkaConsumer != nil </span><span class="cov0" title="0">{
                if err := kafkaConsumer.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("kafka close error", logx.Any("err", err))
                }</span>
        }
        <span class="cov0" title="0">if ordersCloser != nil </span><span class="cov0" title="0">{
                if err := ordersCloser(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("orders close error", logx.Any("err", err))
                }</span>
        }
        <span class="cov0" title="0">if pool != nil </span><span class="cov0" title="0">{
                pool.Close()
        }</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package config

import (
        "errors"
        "fmt"
        "os"
        "strconv"
        "strings"
        "sync"
        "time"

        "github.com/joho/godotenv"
        "github.com/spf13/pflag"
)

var flagsMu sync.Mutex

// Config stores HTTP service settings.
type Config struct {
        Port     int
        DB       DB
        Delivery Delivery

        OrderService string
        Kafka        Kafka
}

// DB stores database settings.
type DB struct {
        Host string
        Port string
        User string
        Pass string
        Name string
}

// Kafka stores kafka settings.
type Kafka struct {
        Brokers []string
        Topic   string
        GroupID string
}

// Delivery stores delivery-related settings.
type Delivery struct {
        AutoReleaseInterval time.Duration
}

// DSN returns database connection string.
func (d DB) DSN() string <span class="cov5" title="10">{
        return fmt.Sprintf("postgres://%s:%s@%s:%s/%s?sslmode=disable",
                d.User, d.Pass, d.Host, d.Port, d.Name)
}</span>

// envOrDefault returns environment variable value if set, otherwise default.
func envOrDefault(key, def string) string <span class="cov10" title="142">{
        if v := strings.TrimSpace(os.Getenv(key)); v != "" </span><span class="cov6" title="18">{
                return v
        }</span>
        <span class="cov9" title="124">return def</span>
}

// Load reads configuration in order: .env (if present) → environment → flags.
func Load() (*Config, error) <span class="cov6" title="20">{
        flagsMu.Lock()
        defer flagsMu.Unlock()
        // возвращаем ошибку на верх, но не выходим
        if err := godotenv.Load(".env"); err != nil &amp;&amp; !errors.Is(err, os.ErrNotExist) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("load .env: %w", err)
        }</span>

        <span class="cov6" title="20">port := 8080
        if v := os.Getenv("PORT"); v != "" </span><span class="cov5" title="13">{
                if p, err := strconv.Atoi(v); err == nil </span><span class="cov5" title="13">{
                        port = p
                }</span>
        }

        <span class="cov6" title="20">if pflag.CommandLine.Lookup("port") == nil </span><span class="cov5" title="15">{
                pflag.IntVarP(&amp;port, "port", "p", port, "port to listen on")
        }</span>

        <span class="cov6" title="20">if !pflag.CommandLine.Parsed() </span><span class="cov5" title="15">{
                if err := pflag.CommandLine.Parse(os.Args[1:]); err != nil </span><span class="cov2" title="2">{
                        return nil, fmt.Errorf("parse flags: %w", err)
                }</span>
        }

        <span class="cov6" title="18">if port &lt;= 0 || port &gt; 65535 </span><span class="cov2" title="2">{
                return nil, fmt.Errorf("invalid port: %d", port)
        }</span>

        <span class="cov6" title="16">db := DB{
                Host: envOrDefault("POSTGRES_HOST", "127.0.0.1"),
                Port: envOrDefault("POSTGRES_PORT", "5432"),
                User: envOrDefault("POSTGRES_USER", "myuser"),
                Pass: envOrDefault("POSTGRES_PASSWORD", "mypassword"),
                Name: envOrDefault("POSTGRES_DB", "test_db"),
        }
        if _, err := strconv.Atoi(db.Port); err != nil </span><span class="cov2" title="2">{
                return nil, fmt.Errorf("invalid POSTGRES_PORT: %q", db.Port)
        }</span>

        <span class="cov5" title="14">intervalStr := envOrDefault("DELIVERY_AUTO_RELEASE_INTERVAL", "10s")
        autoReleaseInterval, err := time.ParseDuration(intervalStr)
        if err != nil </span><span class="cov2" title="2">{
                return nil, fmt.Errorf("invalid DELIVERY_AUTO_RELEASE_INTERVAL %q: %w", intervalStr, err)
        }</span>

        <span class="cov5" title="12">deliveryCfg := Delivery{
                AutoReleaseInterval: autoReleaseInterval,
        }
        // orderHost := envOrDefault("ORDER_SERVICE_HOST", "http://localhost:8083")
        orderHost := envOrDefault("ORDER_SERVICE_HOST", "localhost:50051")

        kafkaCfg, err := loadKafka()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov5" title="12">return &amp;Config{Port: port, DB: db, Delivery: deliveryCfg, OrderService: orderHost, Kafka: kafkaCfg}, nil</span>
}

func loadKafka() (Kafka, error) <span class="cov5" title="12">{
        brokersCSV := envOrDefault("KAFKA_BROKERS", "kafka:9092")
        raw := strings.Split(brokersCSV, ",")
        brokers := make([]string, 0, len(raw))
        for _, b := range raw </span><span class="cov5" title="12">{
                b = strings.TrimSpace(b)
                if b != "" </span><span class="cov5" title="12">{
                        brokers = append(brokers, b)
                }</span>
        }
        <span class="cov5" title="12">if len(brokers) == 0 </span><span class="cov0" title="0">{
                return Kafka{}, fmt.Errorf("invalid KAFKA_BROKERS: %q", brokersCSV)
        }</span>

        <span class="cov5" title="12">cfg := Kafka{
                Brokers: brokers,
                Topic:   envOrDefault("KAFKA_ORDER_TOPIC", "order.status.changed"),
                GroupID: envOrDefault("KAFKA_GROUP_ID", "service-courier"),
        }
        if cfg.Topic == "" </span><span class="cov0" title="0">{
                return Kafka{}, fmt.Errorf("invalid KAFKA_ORDER_TOPIC: empty")
        }</span>
        <span class="cov5" title="12">if cfg.GroupID == "" </span><span class="cov0" title="0">{
                return Kafka{}, fmt.Errorf("invalid KAFKA_GROUP_ID: empty")
        }</span>
        <span class="cov5" title="12">return cfg, nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package domain

import "regexp"

// List of possible courier statuses
const (
        StatusAvailable CourierStatus = "available"
        StatusBusy      CourierStatus = "busy"
        StatusPaused    CourierStatus = "paused"
)

// List of possible courier transport types
const (
        TransportTypeFoot    CourierTransportType = "on_foot"
        TransportTypeScooter CourierTransportType = "scooter"
        TransportTypeCar     CourierTransportType = "car"
)

// List of allowed statuses
var allowedStatuses = [...]CourierStatus{
        StatusAvailable, StatusBusy, StatusPaused,
}

var allowedTransportTypes = [...]CourierTransportType{
        TransportTypeFoot, TransportTypeScooter, TransportTypeCar,
}

// Valid checks if the CourierStatus is valid
func (s CourierStatus) Valid() bool <span class="cov8" title="16">{
        for _, v := range allowedStatuses </span><span class="cov10" title="26">{
                if s == v </span><span class="cov7" title="12">{
                        return true
                }</span>
        }
        <span class="cov4" title="4">return false</span>
}

// Valid checks if the CourierTransportType is valid
func (t CourierTransportType) Valid() bool <span class="cov8" title="14">{
        for _, v := range allowedTransportTypes </span><span class="cov10" title="26">{
                if t == v </span><span class="cov7" title="10">{
                        return true
                }</span>
        }
        <span class="cov4" title="4">return false</span>
}

var rePhone = regexp.MustCompile(`^\+[0-9]{11}$`)

// ValidatePhone validates the phone number format
func ValidatePhone(s string) bool <span class="cov8" title="14">{
        return rePhone.MatchString(s)
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package order

import (
        "context"
        "fmt"
        "time"

        "google.golang.org/protobuf/types/known/timestamppb"

        ordersproto "course-go-avito-Orurh/internal/proto"
)

// Order represents an order from the orders service.
type Order struct {
        ID        string
        Status    string
        CreatedAt time.Time
}

// GRPCGateway is an orders gateway backed by gRPC.
type GRPCGateway struct {
        client ordersproto.OrdersServiceClient
}

// NewGRPCGateway creates an orders gateway backed by gRPC.
func NewGRPCGateway(client ordersproto.OrdersServiceClient) *GRPCGateway <span class="cov10" title="14">{
        if client == nil </span><span class="cov3" title="2">{
                return nil
        }</span>
        <span class="cov9" title="12">return &amp;GRPCGateway{client: client}</span>
}

func mapProtoOrder(o *ordersproto.Order) Order <span class="cov8" title="8">{
        var createdAt time.Time
        if ts := o.GetCreatedAt(); ts != nil </span><span class="cov5" title="4">{
                createdAt = ts.AsTime()
        }</span>
        <span class="cov8" title="8">return Order{
                ID:        o.GetId(),
                Status:    o.GetStatus(),
                CreatedAt: createdAt,
        }</span>
}

// GetByID fetches an order by ID from the orders service.
func (g *GRPCGateway) GetByID(ctx context.Context, id string) (*Order, error) <span class="cov8" title="8">{
        resp, err := g.client.GetOrderById(ctx, &amp;ordersproto.GetOrderByIdRequest{Id: id})
        if err != nil </span><span class="cov3" title="2">{
                return nil, fmt.Errorf("order gateway: GetOrderById: %w", err)
        }</span>
        <span class="cov7" title="6">if resp.Order == nil </span><span class="cov3" title="2">{
                return nil, nil
        }</span>
        <span class="cov5" title="4">ord := mapProtoOrder(resp.GetOrder())
        return &amp;ord, nil</span>
}

// ListFrom список заказов через gRPC, не используется
func (g *GRPCGateway) ListFrom(ctx context.Context, from time.Time) ([]Order, error) <span class="cov5" title="4">{
        req := &amp;ordersproto.GetOrdersRequest{
                From: timestamppb.New(from.UTC()),
        }
        resp, err := g.client.GetOrders(ctx, req)
        if err != nil </span><span class="cov3" title="2">{
                return nil, fmt.Errorf("order gateway: GetOrders: %w", err)
        }</span>
        <span class="cov3" title="2">orders := make([]Order, 0, len(resp.Orders))
        for _, o := range resp.GetOrders() </span><span class="cov7" title="6">{
                if o == nil </span><span class="cov3" title="2">{
                        continue</span>
                }
                <span class="cov5" title="4">orders = append(orders, mapProtoOrder(o))</span>
        }

        <span class="cov3" title="2">return orders, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package handlers

import (
        "context"

        "course-go-avito-Orurh/internal/domain"
        "course-go-avito-Orurh/internal/service/courier"
        "course-go-avito-Orurh/internal/service/delivery"
)

// courierUsecase exposes courier-related business operations to the HTTP layer.
type courierUsecase interface {
        Get(ctx context.Context, id int64) (*domain.Courier, error)
        List(ctx context.Context, limit, offset *int) ([]domain.Courier, error)
        Create(ctx context.Context, c *domain.Courier) (int64, error)
        UpdatePartial(ctx context.Context, u domain.PartialCourierUpdate) (bool, error)
}

// NewCourierUsecase wires a CourierService into a courierUsecase.
func NewCourierUsecase(service *courier.Service) courierUsecase <span class="cov10" title="2">{
        return service
}</span>

type deliveryUsecase interface {
        Assign(ctx context.Context, orderID string) (domain.AssignResult, error)
        Unassign(ctx context.Context, orderID string) (domain.UnassignResult, error)
}

// NewDeliveryUsecase wires a DeliveryService into a deliveryUsecase.
func NewDeliveryUsecase(svc *delivery.Service) deliveryUsecase <span class="cov10" title="2">{
        return svc
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package handlers

import (
        "errors"
        "net/http"
        "strconv"

        "course-go-avito-Orurh/internal/apperr"
        "course-go-avito-Orurh/internal/logx"
)

// CourierHandler serves HTTP endpoints for courier resources.
type CourierHandler struct {
        usecase courierUsecase
        logger  logx.Logger
}

// NewCourierHandler wires a CourierUsecase into HTTP handlers.
func NewCourierHandler(logger logx.Logger, uc courierUsecase) *CourierHandler <span class="cov10" title="40">{
        return &amp;CourierHandler{usecase: uc, logger: logger}
}</span>

// GetByID handles GET /courier/{id}.
func (h *CourierHandler) GetByID(w http.ResponseWriter, r *http.Request) <span class="cov6" title="8">{
        id, err := idFromURL(r, "id")
        if err != nil </span><span class="cov2" title="2">{
                writeError(h.logger, w, r, http.StatusBadRequest, "invalid id")
                return
        }</span>

        <span class="cov5" title="6">c, err := h.usecase.Get(r.Context(), id)
        switch </span>{
        case err == nil:<span class="cov2" title="2">
                writeJSON(h.logger, w, r, http.StatusOK, modelToResponse(*c))</span>
        case errors.Is(err, apperr.ErrNotFound):<span class="cov2" title="2">
                writeError(h.logger, w, r, http.StatusNotFound, "not found")</span>
        default:<span class="cov2" title="2">
                writeError(h.logger, w, r, http.StatusInternalServerError, "internal error")</span>
        }
}

// List handles GET /couriers.
func (h *CourierHandler) List(w http.ResponseWriter, r *http.Request) <span class="cov6" title="8">{
        q := r.URL.Query()
        var limitPtr, offsetPtr *int
        if s := q.Get("limit"); s != "" </span><span class="cov4" title="4">{
                v, err := strconv.Atoi(s)
                if err != nil || v &lt; 0 </span><span class="cov2" title="2">{
                        writeError(h.logger, w, r, http.StatusBadRequest, "invalid limit")
                        return
                }</span>
                <span class="cov2" title="2">limitPtr = &amp;v</span>
        }
        <span class="cov5" title="6">if s := q.Get("offset"); s != "" </span><span class="cov4" title="4">{
                v, err := strconv.Atoi(s)
                if err != nil || v &lt; 0 </span><span class="cov2" title="2">{
                        writeError(h.logger, w, r, http.StatusBadRequest, "invalid offset")
                        return
                }</span>
                <span class="cov2" title="2">offsetPtr = &amp;v</span>
        }

        <span class="cov4" title="4">list, err := h.usecase.List(r.Context(), limitPtr, offsetPtr)
        if err != nil </span><span class="cov2" title="2">{
                writeError(h.logger, w, r, http.StatusInternalServerError, "internal error")
                return
        }</span>
        <span class="cov2" title="2">writeJSON(h.logger, w, r, http.StatusOK, modelsToResponse(list))</span>
}

// Create handles POST /courier.
func (h *CourierHandler) Create(w http.ResponseWriter, r *http.Request) <span class="cov6" title="10">{
        var req createCourierRequest
        if ok := decodeJSON(h.logger, w, r, &amp;req); !ok </span><span class="cov2" title="2">{
                return
        }</span>
        <span class="cov6" title="8">id, err := h.usecase.Create(r.Context(), req.toModel())
        switch </span>{
        case err == nil:<span class="cov2" title="2">
                w.Header().Set("Location", "/courier/"+strconv.FormatInt(id, 10))
                writeJSON(h.logger, w, r, http.StatusCreated, map[string]any{"id": id})</span>
        case errors.Is(err, apperr.ErrInvalid):<span class="cov2" title="2">
                writeError(h.logger, w, r, http.StatusBadRequest, "invalid input")</span>
        case errors.Is(err, apperr.ErrConflict):<span class="cov2" title="2">
                writeError(h.logger, w, r, http.StatusConflict, "phone already exists")</span>
        default:<span class="cov2" title="2">
                writeError(h.logger, w, r, http.StatusInternalServerError, "internal error")</span>
        }
}

// Update handles PUT /courier with partial updates from the request body.
func (h *CourierHandler) Update(w http.ResponseWriter, r *http.Request) <span class="cov7" title="12">{
        var req updateCourierRequest
        if ok := decodeJSON(h.logger, w, r, &amp;req); !ok </span><span class="cov2" title="2">{
                return
        }</span>
        <span class="cov6" title="10">_, err := h.usecase.UpdatePartial(r.Context(), req.toModel())
        switch </span>{
        case err == nil:<span class="cov2" title="2">
                writeJSON(h.logger, w, r, http.StatusOK, map[string]string{"status": "ok"})</span>
        case errors.Is(err, apperr.ErrInvalid):<span class="cov2" title="2">
                writeError(h.logger, w, r, http.StatusBadRequest, "invalid input")</span>
        case errors.Is(err, apperr.ErrConflict):<span class="cov2" title="2">
                writeError(h.logger, w, r, http.StatusConflict, "phone already exists")</span>
        case errors.Is(err, apperr.ErrNotFound):<span class="cov2" title="2">
                writeError(h.logger, w, r, http.StatusNotFound, "not found")</span>
        default:<span class="cov2" title="2">
                writeError(h.logger, w, r, http.StatusInternalServerError, "internal error")</span>
        }
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package handlers

import "course-go-avito-Orurh/internal/domain"

func (req createCourierRequest) toModel() *domain.Courier <span class="cov9" title="8">{
        return &amp;domain.Courier{
                Name:          req.Name,
                Phone:         req.Phone,
                Status:        req.Status,
                TransportType: req.TransportType,
        }
}</span>

func (req updateCourierRequest) toModel() domain.PartialCourierUpdate <span class="cov10" title="10">{
        return domain.PartialCourierUpdate{
                ID:            req.ID,
                Name:          req.Name,
                Phone:         req.Phone,
                Status:        req.Status,
                TransportType: req.TransportType,
        }
}</span>

func modelToResponse(c domain.Courier) courierDTO <span class="cov8" title="6">{
        return courierDTO{
                ID:            c.ID,
                Name:          c.Name,
                Phone:         c.Phone,
                Status:        c.Status,
                TransportType: c.TransportType,
        }
}</span>

func modelsToResponse(list []domain.Courier) []courierDTO <span class="cov3" title="2">{
        out := make([]courierDTO, 0, len(list))
        for _, c := range list </span><span class="cov6" title="4">{
                out = append(out, modelToResponse(c))
        }</span>
        <span class="cov3" title="2">return out</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package handlers

import (
        "errors"
        "net/http"

        "course-go-avito-Orurh/internal/apperr"
        "course-go-avito-Orurh/internal/logx"
)

// DeliveryHandler handles HTTP requests for delivery resources.
type DeliveryHandler struct {
        usecase deliveryUsecase
        logger  logx.Logger
}

// NewDeliveryHandler creates a new DeliveryHandler.
func NewDeliveryHandler(logger logx.Logger, uc deliveryUsecase) *DeliveryHandler <span class="cov10" title="22">{
        return &amp;DeliveryHandler{usecase: uc, logger: logger}
}</span>

// Assign handles the HTTP request for assigning a delivery.
func (h *DeliveryHandler) Assign(w http.ResponseWriter, r *http.Request) <span class="cov7" title="10">{
        var req assignDeliveryRequest
        if ok := decodeJSON(h.logger, w, r, &amp;req); !ok </span><span class="cov3" title="2">{
                return
        }</span>

        <span class="cov7" title="8">res, err := h.usecase.Assign(r.Context(), req.OrderID)
        switch </span>{
        case err == nil:<span class="cov3" title="2">
                writeJSON(h.logger, w, r, http.StatusOK, assignResultToResponse(res))</span>
        case errors.Is(err, apperr.ErrInvalid):<span class="cov3" title="2">
                writeError(h.logger, w, r, http.StatusBadRequest, "invalid input")</span>
        case errors.Is(err, apperr.ErrConflict):<span class="cov3" title="2">
                writeError(h.logger, w, r, http.StatusConflict, "no available couriers")</span>
        default:<span class="cov3" title="2">
                writeError(h.logger, w, r, http.StatusInternalServerError, "internal error")</span>
        }
}

// Unassign handles the HTTP request for unassigning a delivery.
func (h *DeliveryHandler) Unassign(w http.ResponseWriter, r *http.Request) <span class="cov7" title="10">{
        var req unassignDeliveryRequest
        if ok := decodeJSON(h.logger, w, r, &amp;req); !ok </span><span class="cov3" title="2">{
                return
        }</span>

        <span class="cov7" title="8">res, err := h.usecase.Unassign(r.Context(), req.OrderID)
        switch </span>{
        case err == nil:<span class="cov3" title="2">
                writeJSON(h.logger, w, r, http.StatusOK, unassignResultToResponse(res))</span>
        case errors.Is(err, apperr.ErrInvalid):<span class="cov3" title="2">
                writeError(h.logger, w, r, http.StatusBadRequest, "invalid input")</span>
        case errors.Is(err, apperr.ErrNotFound):<span class="cov3" title="2">
                writeError(h.logger, w, r, http.StatusNotFound, "delivery not found")</span>
        default:<span class="cov3" title="2">
                writeError(h.logger, w, r, http.StatusInternalServerError, "internal error")</span>
        }
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package handlers

import "course-go-avito-Orurh/internal/domain"

func assignResultToResponse(result domain.AssignResult) assignDeliveryResponse <span class="cov10" title="2">{
        return assignDeliveryResponse{
                CourierID:        result.CourierID,
                OrderID:          result.OrderID,
                TransportType:    string(result.TransportType),
                DeliveryDeadline: result.Deadline,
        }
}</span>

func unassignResultToResponse(result domain.UnassignResult) unassignDeliveryResponse <span class="cov10" title="2">{
        return unassignDeliveryResponse{
                OrderID:   result.OrderID,
                Status:    result.Status,
                CourierID: result.CourierID,
        }
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package handlers

import (
        "net/http"

        "course-go-avito-Orurh/internal/logx"
)

// Handlers holds HTTP handlers dependencies (logger, etc.).
type Handlers struct {
        Logger logx.Logger
}

// New creates a Handlers instance with the given logger (or a panic).
func New(logger logx.Logger) *Handlers <span class="cov10" title="8">{
        return &amp;Handlers{Logger: logger}
}</span>

// Ping handles GET /ping and returns 200 with {"message":"pong"}.
func (h *Handlers) Ping(w http.ResponseWriter, r *http.Request) <span class="cov4" title="2">{
        writeJSON(h.Logger, w, r, http.StatusOK, map[string]string{"message": "pong"})
}</span>

// HealthcheckHead handles HEAD /healthcheck and returns 204 No Content.
func (h *Handlers) HealthcheckHead(w http.ResponseWriter, _ *http.Request) <span class="cov4" title="2">{
        w.WriteHeader(http.StatusNoContent)
}</span>

// NotFound returns a JSON 404 error for unknown routes.
func (h *Handlers) NotFound(w http.ResponseWriter, r *http.Request) <span class="cov4" title="2">{
        writeError(h.Logger, w, r, http.StatusNotFound, "route not found")
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package handlers

import (
        "context"
        "encoding/json"
        "errors"
        "io"
        "net/http"
        "strconv"

        "course-go-avito-Orurh/internal/logx"

        "github.com/go-chi/chi/v5"
        "github.com/go-chi/chi/v5/middleware"
)

func reqID(ctx context.Context) string <span class="cov8" title="56">{
        if id := middleware.GetReqID(ctx); id != "" </span><span class="cov0" title="0">{
                return id
        }</span>
        <span class="cov8" title="56">return "-"</span>
}

// логгер обязательный
func mustLogger(logger logx.Logger) logx.Logger <span class="cov10" title="152">{
        return logger
}</span>

func writeJSON(logger logx.Logger, w http.ResponseWriter, r *http.Request, status int, v any) <span class="cov8" title="62">{
        logger = mustLogger(logger)
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(status)

        enc := json.NewEncoder(w)
        enc.SetEscapeHTML(false)
        if err := enc.Encode(v); err != nil </span><span class="cov0" title="0">{
                logger.Error("json encode error", logx.String("req_id", reqID(r.Context())), logx.Any("err", err))
        }</span>
}

type errResponse struct {
        Error string `json:"error"`
}

func writeError(logger logx.Logger, w http.ResponseWriter, r *http.Request, status int, msg string) <span class="cov7" title="48">{
        logger = mustLogger(logger)
        logger.Warn("http_error", logx.String("req_id", reqID(r.Context())), logx.Int("status", status), logx.String("msg", msg))
        writeJSON(logger, w, r, status, errResponse{Error: msg})
}</span>

const (
        bodyLimit = 1 &lt;&lt; 20
)

func decodeJSON[T any](logger logx.Logger, w http.ResponseWriter, r *http.Request, dst *T) bool <span class="cov7" title="42">{
        logger = mustLogger(logger)
        r.Body = http.MaxBytesReader(w, r.Body, bodyLimit)
        dec := json.NewDecoder(r.Body)
        dec.DisallowUnknownFields()
        if err := dec.Decode(dst); err != nil </span><span class="cov4" title="8">{
                var mbe *http.MaxBytesError
                // добавил логирование о превышении лимита тела
                if errors.As(err, &amp;mbe) </span><span class="cov0" title="0">{
                        logger.Warn("body too large", logx.String("req_id", reqID(r.Context())), logx.Int64("limit_bytes",
                                int64(mbe.Limit)), logx.Int64("content_length", r.ContentLength), logx.Any("err", err))
                        writeError(logger, w, r, http.StatusRequestEntityTooLarge, "body too large")
                        return false
                }</span>

                <span class="cov4" title="8">logger.Warn("json decode error",
                        logx.String("req_id", reqID(r.Context())),
                        logx.Any("err", err),
                )
                writeError(logger, w, r, http.StatusBadRequest, "invalid json")
                return false</span>
        }
        <span class="cov7" title="34">if err := dec.Decode(new(struct{})); err != io.EOF </span><span class="cov0" title="0">{
                logger.Warn("json trailing data", logx.String("req_id", reqID(r.Context())), logx.Any("err", err))
                writeError(logger, w, r, http.StatusBadRequest, "invalid json: trailing data")
                return false
        }</span>
        <span class="cov7" title="34">return true</span>
}

func idFromURL(r *http.Request, name string) (int64, error) <span class="cov4" title="8">{
        idStr := chi.URLParam(r, name)
        id, err := strconv.ParseInt(idStr, 10, 64)
        if err != nil || id &lt;= 0 </span><span class="cov2" title="2">{
                return 0, errors.New("invalid id")
        }</span>
        <span class="cov4" title="6">return id, nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package middleware

import (
        "net/http"
        "strconv"
        "time"

        "course-go-avito-Orurh/internal/logx"

        "github.com/go-chi/chi/v5"
        chimw "github.com/go-chi/chi/v5/middleware"
        "github.com/prometheus/client_golang/prometheus"
)

var (
        httpRequestsTotal = prometheus.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "http_requests_total",
                        Help: "Total number of HTTP requests",
                },
                []string{"method", "path", "status"},
        )
        httpRequestDuration = prometheus.NewHistogramVec(
                prometheus.HistogramOpts{
                        Name:    "http_request_duration_seconds",
                        Help:    "Duration of HTTP requests.",
                        Buckets: prometheus.DefBuckets,
                },
                []string{"method", "path", "status"},
        )
)

// init регистрируем метрики
func init() <span class="cov10" title="4">{
        prometheus.MustRegister(httpRequestsTotal, httpRequestDuration)
}</span>

// Observability - middleware for prometheus
func Observability(logger logx.Logger) func(http.Handler) http.Handler <span class="cov5" title="2">{
        return func(next http.Handler) http.Handler </span><span class="cov5" title="2">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        start := time.Now()
                        ww := chimw.NewWrapResponseWriter(w, r.ProtoMajor) // через прокси читаем ответ
                        next.ServeHTTP(ww, r)                              // пропускаем дальше
                        path := pathPattern(r)                             // что бы не взорвать прометеус
                        tm := time.Since(start)
                        status := strconv.Itoa(ww.Status())

                        httpRequestsTotal.WithLabelValues(r.Method, path, status).Inc()
                        httpRequestDuration.WithLabelValues(r.Method, path, status).Observe(tm.Seconds())

                        logger.Info("http request",
                                logx.String("method", r.Method),
                                logx.String("path", path),
                                logx.Int("status", ww.Status()),
                                logx.Duration("duration", tm),
                        )
                }</span>)
        }
}

func pathPattern(r *http.Request) string <span class="cov0" title="0">{
        rc := chi.RouteContext(r.Context())
        if rc != nil </span><span class="cov0" title="0">{
                if p := rc.RoutePattern(); p != "" </span><span class="cov0" title="0">{
                        return p
                }</span>
        }
        <span class="cov0" title="0">return r.URL.Path</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package router

import (
        "net/http"
        "time"

        "github.com/go-chi/chi/v5"
        "github.com/go-chi/chi/v5/middleware"
        "github.com/prometheus/client_golang/prometheus/promhttp"

        "course-go-avito-Orurh/internal/http/handlers"
        obsmw "course-go-avito-Orurh/internal/http/middleware"
)

// New constructs a chi-based http.Handler with base middleware and routes.
func New(base *handlers.Handlers, cour *handlers.CourierHandler, delivery *handlers.DeliveryHandler) http.Handler <span class="cov10" title="2">{
        r := chi.NewRouter()

        r.Use(middleware.RequestID)
        r.Use(middleware.RealIP)
        // r.Use(middleware.Logger)
        r.Use(obsmw.Observability(base.Logger))
        r.Use(middleware.Recoverer)
        r.Use(middleware.Timeout(5 * time.Second))

        r.Get("/ping", base.Ping)
        r.Get("/metrics", promhttp.Handler().ServeHTTP)
        r.Method(http.MethodHead, "/healthcheck", http.HandlerFunc(base.HealthcheckHead))
        r.NotFound(http.HandlerFunc(base.NotFound))

        r.Get("/courier/{id}", cour.GetByID)
        r.Get("/couriers", cour.List)
        r.Post("/courier", cour.Create)
        r.Put("/courier", cour.Update)

        r.Post("/delivery/assign", delivery.Assign)
        r.Post("/delivery/unassign", delivery.Unassign)
        return r
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package logx

import "log/slog"

type SlogAdapter struct {
        l *slog.Logger
}

func NewSlogAdapter(l *slog.Logger) Logger <span class="cov10" title="7">{
        return &amp;SlogAdapter{l: l}
}</span>

func (s *SlogAdapter) Debug(msg string, fields ...Field) <span class="cov0" title="0">{ s.l.Debug(msg, toSlogArgs(fields)...) }</span>
func (s *SlogAdapter) Info(msg string, fields ...Field)  <span class="cov1" title="1">{ s.l.Info(msg, toSlogArgs(fields)...) }</span>
func (s *SlogAdapter) Warn(msg string, fields ...Field)  <span class="cov0" title="0">{ s.l.Warn(msg, toSlogArgs(fields)...) }</span>
func (s *SlogAdapter) Error(msg string, fields ...Field) <span class="cov0" title="0">{ s.l.Error(msg, toSlogArgs(fields)...) }</span>

func (s *SlogAdapter) With(fields ...Field) Logger <span class="cov0" title="0">{
        return &amp;SlogAdapter{l: s.l.With(toSlogArgs(fields)...)}
}</span>

func (s *SlogAdapter) Sync() error <span class="cov0" title="0">{ return nil }</span> // для slog обычно noop

func toSlogArgs(fields []Field) []any <span class="cov1" title="1">{
        args := make([]any, 0, len(fields))
        for _, f := range fields </span><span class="cov1" title="1">{
                args = append(args, slog.Any(f.Key, f.Value))
        }</span>
        <span class="cov1" title="1">return args</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package logx

import "time"

type Logger interface {
        Debug(msg string, fields ...Field)
        Info(msg string, fields ...Field)
        Warn(msg string, fields ...Field)
        Error(msg string, fields ...Field)
        With(fields ...Field) Logger
        Sync() error
}

type Field struct {
        Key   string
        Value any
}

func Any(key string, value any) Field <span class="cov6" title="16">{
        return Field{Key: key, Value: value}
}</span>

func String(key, value string) Field <span class="cov10" title="116">{
        return Field{Key: key, Value: value}
}</span>

func Int(key string, value int) Field <span class="cov8" title="58">{
        return Field{Key: key, Value: value}
}</span>

func Int64(key string, value int64) Field <span class="cov2" title="2">{
        return Field{Key: key, Value: value}
}</span>

func Time(key string, value time.Time) Field <span class="cov2" title="2">{
        return Field{Key: key, Value: value}
}</span>

func Duration(key string, value time.Duration) Field <span class="cov0" title="0">{
        return Field{Key: key, Value: value}
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package logx

type nopLogger struct{}

func Nop() Logger <span class="cov10" title="111">{ return nopLogger{} }</span>

func (nopLogger) Debug(string, ...Field) {<span class="cov0" title="0">}</span>
func (nopLogger) Info(string, ...Field)  {<span class="cov4" title="7">}</span>
func (nopLogger) Warn(string, ...Field)  {<span class="cov8" title="60">}</span>
func (nopLogger) Error(string, ...Field) {<span class="cov0" title="0">}</span>

func (nopLogger) With(...Field) Logger <span class="cov0" title="0">{ return nopLogger{} }</span>
func (nopLogger) Sync() error          <span class="cov0" title="0">{ return nil }</span>

var _ Logger = nopLogger{}
</pre>
		
		<pre class="file" id="file21" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.36.10
//         protoc        v3.21.12
// source: orders.proto

package orderspb

import (
        reflect "reflect"
        sync "sync"
        unsafe "unsafe"

        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        timestamppb "google.golang.org/protobuf/types/known/timestamppb"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Минимальная модель заказа, которую используем в service-courier:
// номера полей и типы ДОЛЖНЫ совпасть с сервером.
type Order struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        Status        string                 `protobuf:"bytes,9,opt,name=status,proto3" json:"status,omitempty"`
        CreatedAt     *timestamppb.Timestamp `protobuf:"bytes,10,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Order) Reset() <span class="cov0" title="0">{
        *x = Order{}
        mi := &amp;file_orders_proto_msgTypes[0]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Order) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Order) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Order) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_orders_proto_msgTypes[0]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Order.ProtoReflect.Descriptor instead.
func (*Order) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_orders_proto_rawDescGZIP(), []int{0}
}</span>

func (x *Order) GetId() string <span class="cov10" title="8">{
        if x != nil </span><span class="cov10" title="8">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Order) GetStatus() string <span class="cov10" title="8">{
        if x != nil </span><span class="cov10" title="8">{
                return x.Status
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Order) GetCreatedAt() *timestamppb.Timestamp <span class="cov10" title="8">{
        if x != nil </span><span class="cov10" title="8">{
                return x.CreatedAt
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Запрос на получение списка заказов
type GetOrdersRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        From          *timestamppb.Timestamp `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetOrdersRequest) Reset() <span class="cov0" title="0">{
        *x = GetOrdersRequest{}
        mi := &amp;file_orders_proto_msgTypes[1]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetOrdersRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetOrdersRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetOrdersRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_orders_proto_msgTypes[1]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetOrdersRequest.ProtoReflect.Descriptor instead.
func (*GetOrdersRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_orders_proto_rawDescGZIP(), []int{1}
}</span>

func (x *GetOrdersRequest) GetFrom() *timestamppb.Timestamp <span class="cov7" title="4">{
        if x != nil </span><span class="cov7" title="4">{
                return x.From
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Запрос на получение заказа по id
type GetOrderByIdRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetOrderByIdRequest) Reset() <span class="cov0" title="0">{
        *x = GetOrderByIdRequest{}
        mi := &amp;file_orders_proto_msgTypes[2]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetOrderByIdRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetOrderByIdRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetOrderByIdRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_orders_proto_msgTypes[2]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetOrderByIdRequest.ProtoReflect.Descriptor instead.
func (*GetOrderByIdRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_orders_proto_rawDescGZIP(), []int{2}
}</span>

func (x *GetOrderByIdRequest) GetId() string <span class="cov4" title="2">{
        if x != nil </span><span class="cov4" title="2">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// Ответ на запрос получения заказов
type GetOrdersResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Orders        []*Order               `protobuf:"bytes,1,rep,name=orders,proto3" json:"orders,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetOrdersResponse) Reset() <span class="cov0" title="0">{
        *x = GetOrdersResponse{}
        mi := &amp;file_orders_proto_msgTypes[3]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetOrdersResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetOrdersResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetOrdersResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_orders_proto_msgTypes[3]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetOrdersResponse.ProtoReflect.Descriptor instead.
func (*GetOrdersResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_orders_proto_rawDescGZIP(), []int{3}
}</span>

func (x *GetOrdersResponse) GetOrders() []*Order <span class="cov4" title="2">{
        if x != nil </span><span class="cov4" title="2">{
                return x.Orders
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Ответ на запрос получения заказа по id
type GetOrderByIdResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Order         *Order                 `protobuf:"bytes,1,opt,name=order,proto3" json:"order,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetOrderByIdResponse) Reset() <span class="cov0" title="0">{
        *x = GetOrderByIdResponse{}
        mi := &amp;file_orders_proto_msgTypes[4]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetOrderByIdResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetOrderByIdResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetOrderByIdResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_orders_proto_msgTypes[4]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetOrderByIdResponse.ProtoReflect.Descriptor instead.
func (*GetOrderByIdResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_orders_proto_rawDescGZIP(), []int{4}
}</span>

func (x *GetOrderByIdResponse) GetOrder() *Order <span class="cov7" title="4">{
        if x != nil </span><span class="cov7" title="4">{
                return x.Order
        }</span>
        <span class="cov0" title="0">return nil</span>
}

var File_orders_proto protoreflect.FileDescriptor

const file_orders_proto_rawDesc = "" +
        "\n" +
        "\forders.proto\x12\torders.v1\x1a\x1fgoogle/protobuf/timestamp.proto\"j\n" +
        "\x05Order\x12\x0e\n" +
        "\x02id\x18\x01 \x01(\tR\x02id\x12\x16\n" +
        "\x06status\x18\t \x01(\tR\x06status\x129\n" +
        "\n" +
        "created_at\x18\n" +
        " \x01(\v2\x1a.google.protobuf.TimestampR\tcreatedAt\"B\n" +
        "\x10GetOrdersRequest\x12.\n" +
        "\x04from\x18\x01 \x01(\v2\x1a.google.protobuf.TimestampR\x04from\"%\n" +
        "\x13GetOrderByIdRequest\x12\x0e\n" +
        "\x02id\x18\x01 \x01(\tR\x02id\"=\n" +
        "\x11GetOrdersResponse\x12(\n" +
        "\x06orders\x18\x01 \x03(\v2\x10.orders.v1.OrderR\x06orders\"&gt;\n" +
        "\x14GetOrderByIdResponse\x12&amp;\n" +
        "\x05order\x18\x01 \x01(\v2\x10.orders.v1.OrderR\x05order2\xa8\x01\n" +
        "\rOrdersService\x12F\n" +
        "\tGetOrders\x12\x1b.orders.v1.GetOrdersRequest\x1a\x1c.orders.v1.GetOrdersResponse\x12O\n" +
        "\fGetOrderById\x12\x1e.orders.v1.GetOrderByIdRequest\x1a\x1f.orders.v1.GetOrderByIdResponseB/Z-course-go-avito-Orurh/internal/proto;orderspbb\x06proto3"

var (
        file_orders_proto_rawDescOnce sync.Once
        file_orders_proto_rawDescData []byte
)

func file_orders_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_orders_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_orders_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_orders_proto_rawDesc), len(file_orders_proto_rawDesc)))
        }</span>)
        <span class="cov0" title="0">return file_orders_proto_rawDescData</span>
}

var (
        file_orders_proto_msgTypes = make([]protoimpl.MessageInfo, 5)
        file_orders_proto_goTypes  = []any{
                (*Order)(nil),                 // 0: orders.v1.Order
                (*GetOrdersRequest)(nil),      // 1: orders.v1.GetOrdersRequest
                (*GetOrderByIdRequest)(nil),   // 2: orders.v1.GetOrderByIdRequest
                (*GetOrdersResponse)(nil),     // 3: orders.v1.GetOrdersResponse
                (*GetOrderByIdResponse)(nil),  // 4: orders.v1.GetOrderByIdResponse
                (*timestamppb.Timestamp)(nil), // 5: google.protobuf.Timestamp
        }
)

var file_orders_proto_depIdxs = []int32{
        5, // 0: orders.v1.Order.created_at:type_name -&gt; google.protobuf.Timestamp
        5, // 1: orders.v1.GetOrdersRequest.from:type_name -&gt; google.protobuf.Timestamp
        0, // 2: orders.v1.GetOrdersResponse.orders:type_name -&gt; orders.v1.Order
        0, // 3: orders.v1.GetOrderByIdResponse.order:type_name -&gt; orders.v1.Order
        1, // 4: orders.v1.OrdersService.GetOrders:input_type -&gt; orders.v1.GetOrdersRequest
        2, // 5: orders.v1.OrdersService.GetOrderById:input_type -&gt; orders.v1.GetOrderByIdRequest
        3, // 6: orders.v1.OrdersService.GetOrders:output_type -&gt; orders.v1.GetOrdersResponse
        4, // 7: orders.v1.OrdersService.GetOrderById:output_type -&gt; orders.v1.GetOrderByIdResponse
        6, // [6:8] is the sub-list for method output_type
        4, // [4:6] is the sub-list for method input_type
        4, // [4:4] is the sub-list for extension type_name
        4, // [4:4] is the sub-list for extension extendee
        0, // [0:4] is the sub-list for field type_name
}

func init() <span class="cov7" title="4">{ file_orders_proto_init() }</span>
func file_orders_proto_init() <span class="cov7" title="4">{
        if File_orders_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov7" title="4">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: unsafe.Slice(unsafe.StringData(file_orders_proto_rawDesc), len(file_orders_proto_rawDesc)),
                        NumEnums:      0,
                        NumMessages:   5,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_orders_proto_goTypes,
                DependencyIndexes: file_orders_proto_depIdxs,
                MessageInfos:      file_orders_proto_msgTypes,
        }.Build()
        File_orders_proto = out.File
        file_orders_proto_goTypes = nil
        file_orders_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             v3.21.12
// source: orders.proto

package orderspb

import (
        context "context"

        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
        OrdersService_GetOrders_FullMethodName    = "/orders.v1.OrdersService/GetOrders"
        OrdersService_GetOrderById_FullMethodName = "/orders.v1.OrdersService/GetOrderById"
)

// OrdersServiceClient is the client API for OrdersService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Интерфейс службы, возвращающей заказы
type OrdersServiceClient interface {
        GetOrders(ctx context.Context, in *GetOrdersRequest, opts ...grpc.CallOption) (*GetOrdersResponse, error)
        GetOrderById(ctx context.Context, in *GetOrderByIdRequest, opts ...grpc.CallOption) (*GetOrderByIdResponse, error)
}

type ordersServiceClient struct {
        cc grpc.ClientConnInterface
}

func NewOrdersServiceClient(cc grpc.ClientConnInterface) OrdersServiceClient <span class="cov0" title="0">{
        return &amp;ordersServiceClient{cc}
}</span>

func (c *ordersServiceClient) GetOrders(ctx context.Context, in *GetOrdersRequest, opts ...grpc.CallOption) (*GetOrdersResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GetOrdersResponse)
        err := c.cc.Invoke(ctx, OrdersService_GetOrders_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *ordersServiceClient) GetOrderById(ctx context.Context, in *GetOrderByIdRequest, opts ...grpc.CallOption) (*GetOrderByIdResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GetOrderByIdResponse)
        err := c.cc.Invoke(ctx, OrdersService_GetOrderById_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// OrdersServiceServer is the server API for OrdersService service.
// All implementations must embed UnimplementedOrdersServiceServer
// for forward compatibility.
//
// Интерфейс службы, возвращающей заказы
type OrdersServiceServer interface {
        GetOrders(context.Context, *GetOrdersRequest) (*GetOrdersResponse, error)
        GetOrderById(context.Context, *GetOrderByIdRequest) (*GetOrderByIdResponse, error)
        mustEmbedUnimplementedOrdersServiceServer()
}

// UnimplementedOrdersServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedOrdersServiceServer struct{}

func (UnimplementedOrdersServiceServer) GetOrders(context.Context, *GetOrdersRequest) (*GetOrdersResponse, error) <span class="cov0" title="0">{
        return nil, status.Error(codes.Unimplemented, "method GetOrders not implemented")
}</span>

func (UnimplementedOrdersServiceServer) GetOrderById(context.Context, *GetOrderByIdRequest) (*GetOrderByIdResponse, error) <span class="cov0" title="0">{
        return nil, status.Error(codes.Unimplemented, "method GetOrderById not implemented")
}</span>
func (UnimplementedOrdersServiceServer) mustEmbedUnimplementedOrdersServiceServer() {<span class="cov0" title="0">}</span>
func (UnimplementedOrdersServiceServer) testEmbeddedByValue()                       {<span class="cov0" title="0">}</span>

// UnsafeOrdersServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to OrdersServiceServer will
// result in compilation errors.
type UnsafeOrdersServiceServer interface {
        mustEmbedUnimplementedOrdersServiceServer()
}

func RegisterOrdersServiceServer(s grpc.ServiceRegistrar, srv OrdersServiceServer) <span class="cov0" title="0">{
        // If the following call panics, it indicates UnimplementedOrdersServiceServer was
        // embedded by pointer and is nil.  This will cause panics if an
        // unimplemented method is ever invoked, so we test this at initialization
        // time to prevent it from happening at runtime later due to I/O.
        if t, ok := srv.(interface{ testEmbeddedByValue() }); ok </span><span class="cov0" title="0">{
                t.testEmbeddedByValue()
        }</span>
        <span class="cov0" title="0">s.RegisterService(&amp;OrdersService_ServiceDesc, srv)</span>
}

func _OrdersService_GetOrders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetOrdersRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(OrdersServiceServer).GetOrders(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: OrdersService_GetOrders_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(OrdersServiceServer).GetOrders(ctx, req.(*GetOrdersRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _OrdersService_GetOrderById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetOrderByIdRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(OrdersServiceServer).GetOrderById(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: OrdersService_GetOrderById_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(OrdersServiceServer).GetOrderById(ctx, req.(*GetOrderByIdRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// OrdersService_ServiceDesc is the grpc.ServiceDesc for OrdersService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var OrdersService_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "orders.v1.OrdersService",
        HandlerType: (*OrdersServiceServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "GetOrders",
                        Handler:    _OrdersService_GetOrders_Handler,
                },
                {
                        MethodName: "GetOrderById",
                        Handler:    _OrdersService_GetOrderById_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "orders.proto",
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package repository

import (
        "context"
        "fmt"

        "github.com/jackc/pgx/v5/pgxpool"

        "course-go-avito-Orurh/internal/apperr"
        "course-go-avito-Orurh/internal/domain"
)

// CourierRepo represents courier repository.
type CourierRepo struct{ db *pgxpool.Pool }

// NewCourierRepo creates a new CourierRepo.
func NewCourierRepo(db *pgxpool.Pool) *CourierRepo <span class="cov5" title="4">{ return &amp;CourierRepo{db: db} }</span>

// Get - returns courier by its ID.
func (r *CourierRepo) Get(ctx context.Context, id int64) (*domain.Courier, error) <span class="cov6" title="6">{
        var c domain.Courier
        err := r.db.QueryRow(ctx,
                `SELECT id, name, phone, status, transport_type FROM couriers WHERE id=$1`, id,
        ).Scan(&amp;c.ID, &amp;c.Name, &amp;c.Phone, &amp;c.Status, &amp;c.TransportType)
        if err != nil </span><span class="cov1" title="1">{
                if IsNotFound(err) </span><span class="cov1" title="1">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("get courier %d: %w", id, err)</span>
        }
        <span class="cov5" title="5">return &amp;c, nil</span>
}

// List returns couriers ordered by id. If limit/offset are nil, returns the full list.
func (r *CourierRepo) List(ctx context.Context, limit, offset *int) ([]domain.Courier, error) <span class="cov1" title="1">{
        q := `SELECT id, name, phone, status, transport_type FROM couriers ORDER BY id`
        args := make([]any, 0, 2)
        if limit != nil </span><span class="cov1" title="1">{
                q += fmt.Sprintf(" LIMIT $%d", len(args)+1)
                args = append(args, *limit)
        }</span>
        <span class="cov1" title="1">if offset != nil </span><span class="cov1" title="1">{
                q += fmt.Sprintf(" OFFSET $%d", len(args)+1)
                args = append(args, *offset)
        }</span>

        <span class="cov1" title="1">rows, err := r.db.Query(ctx, q, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">defer rows.Close()
        capacity := 0
        if limit != nil &amp;&amp; *limit &gt; 0 </span><span class="cov1" title="1">{
                capacity = *limit
        }</span>
        <span class="cov1" title="1">out := make([]domain.Courier, 0, capacity)
        for rows.Next() </span><span class="cov3" title="2">{
                var c domain.Courier
                if err := rows.Scan(&amp;c.ID, &amp;c.Name, &amp;c.Phone, &amp;c.Status, &amp;c.TransportType); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov3" title="2">out = append(out, c)</span>
        }
        <span class="cov1" title="1">return out, rows.Err()</span>
}

// Create - creates a new courier.
func (r *CourierRepo) Create(ctx context.Context, c *domain.Courier) (int64, error) <span class="cov10" title="19">{
        var id int64
        err := r.db.QueryRow(ctx,
                `INSERT INTO couriers(name,phone,status,transport_type) VALUES($1,$2,$3,$4) RETURNING id`,
                c.Name, c.Phone, c.Status, c.TransportType).Scan(&amp;id)
        if err != nil </span><span class="cov1" title="1">{
                if IsDuplicate(err) </span><span class="cov1" title="1">{
                        return 0, apperr.ErrConflict
                }</span>
                <span class="cov0" title="0">return 0, fmt.Errorf("create courier: %w", err)</span>
        }
        <span class="cov9" title="18">return id, nil</span>
}

// UpdatePartial applies a partial update to a courier and returns true if a row was affected.
func (r *CourierRepo) UpdatePartial(ctx context.Context, u domain.PartialCourierUpdate) (bool, error) <span class="cov3" title="2">{
        ct, err := r.db.Exec(ctx, `
        UPDATE couriers
        SET
            name           = COALESCE($2, name),
            phone          = COALESCE($3, phone),
            status         = COALESCE($4, status),
            transport_type = COALESCE($5, transport_type),
            updated_at     = now()
        WHERE id = $1
    `, u.ID, u.Name, u.Phone, u.Status, u.TransportType)
        if err != nil </span><span class="cov1" title="1">{
                if IsDuplicate(err) </span><span class="cov1" title="1">{
                        return false, apperr.ErrConflict
                }</span>
                <span class="cov0" title="0">return false, fmt.Errorf("update courier %d: %w", u.ID, err)</span>
        }
        <span class="cov1" title="1">return ct.RowsAffected() &gt; 0, nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package repository

import (
        "context"

        "github.com/jackc/pgx/v5/pgxpool"
)

// NewPool creates and pings a new pgx connection pool.
func NewPool(ctx context.Context, dsn string) (*pgxpool.Pool, error) <span class="cov10" title="4">{
        pool, err := pgxpool.New(ctx, dsn)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="3">if err := pool.Ping(ctx); err != nil </span><span class="cov1" title="1">{
                pool.Close()
                return nil, err
        }</span>
        <span class="cov5" title="2">return pool, nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package repository

import (
        "context"
        "fmt"
        "time"

        "course-go-avito-Orurh/internal/domain"
        "course-go-avito-Orurh/internal/service/delivery"

        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgxpool"
)

// DeliveryRepo represents delivery repository.
type DeliveryRepo struct {
        db *pgxpool.Pool
}

// NewDeliveryRepo creates a new DeliveryRepo.
func NewDeliveryRepo(db *pgxpool.Pool) *DeliveryRepo <span class="cov5" title="3">{
        return &amp;DeliveryRepo{db: db}
}</span>

// WithTx opens a transaction and executes fn within it.
func (r *DeliveryRepo) WithTx(ctx context.Context, fn func(tx delivery.TxRepository) error) error <span class="cov10" title="10">{
        tx, err := r.db.BeginTx(ctx, pgx.TxOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("begin tx: %w", err)
        }</span>

        <span class="cov10" title="10">wrapped := &amp;txRepo{tx: tx}

        if err := fn(wrapped); err != nil </span><span class="cov3" title="2">{
                if rbErr := tx.Rollback(ctx); rbErr != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("rollback tx: %v (original error: %w)", rbErr, err)
                }</span>
                <span class="cov3" title="2">return err</span>
        }

        <span class="cov9" title="8">if err := tx.Commit(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("commit tx: %w", err)
        }</span>

        <span class="cov9" title="8">return nil</span>
}

type txRepo struct {
        tx pgx.Tx
}

// FindAvailableCourierForUpdate - find available courier for update.
func (r *txRepo) FindAvailableCourierForUpdate(ctx context.Context) (*domain.Courier, error) <span class="cov3" title="2">{
        row := r.tx.QueryRow(ctx, `
        SELECT c.id, c.name, c.phone, c.status, c.transport_type
        FROM couriers c
        WHERE c.status = 'available'
        ORDER BY
            (SELECT COUNT(*) FROM delivery d WHERE d.courier_id = c.id) ASC,
            c.id ASC
        FOR UPDATE
        LIMIT 1
    `)

        var c domain.Courier
        if err := row.Scan(&amp;c.ID, &amp;c.Name, &amp;c.Phone, &amp;c.Status, &amp;c.TransportType); err != nil </span><span class="cov1" title="1">{
                if IsNotFound(err) </span><span class="cov1" title="1">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("find available courier: %w", err)</span>
        }
        <span class="cov1" title="1">return &amp;c, nil</span>
}

// UpdateCourierStatus - update courier status.
func (r *txRepo) UpdateCourierStatus(ctx context.Context, id int64, status domain.CourierStatus) error <span class="cov3" title="2">{
        ct, err := r.tx.Exec(ctx, `
        UPDATE couriers
        SET status = $2, updated_at = now()
        WHERE id = $1
    `, id, string(status))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("update courier status %d: %w", id, err)
        }</span>
        <span class="cov3" title="2">if ct.RowsAffected() == 0 </span><span class="cov1" title="1">{
                return fmt.Errorf("courier %d not found", id)
        }</span>
        <span class="cov1" title="1">return nil</span>
}

// InsertDelivery - insert a new delivery.
func (r *txRepo) InsertDelivery(ctx context.Context, d *domain.Delivery) error <span class="cov3" title="2">{
        err := r.tx.QueryRow(ctx, `
        INSERT INTO delivery (courier_id, order_id, assigned_at, deadline)
        VALUES ($1, $2, $3, $4)
        RETURNING id
    `, d.CourierID, d.OrderID, d.AssignedAt, d.Deadline).Scan(&amp;d.ID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("insert delivery: %w", err)
        }</span>
        <span class="cov3" title="2">return nil</span>
}

// GetByOrderID - get delivery by order ID.
func (r *txRepo) GetByOrderID(ctx context.Context, orderID string) (*domain.Delivery, error) <span class="cov5" title="3">{
        row := r.tx.QueryRow(ctx, `
        SELECT id, courier_id, order_id, assigned_at, deadline
        FROM delivery
        WHERE order_id = $1
    `, orderID)

        var d domain.Delivery
        if err := row.Scan(&amp;d.ID, &amp;d.CourierID, &amp;d.OrderID, &amp;d.AssignedAt, &amp;d.Deadline); err != nil </span><span class="cov1" title="1">{
                if IsNotFound(err) </span><span class="cov1" title="1">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("get delivery by order %q: %w", orderID, err)</span>
        }
        <span class="cov3" title="2">return &amp;d, nil</span>
}

// DeleteByOrderID - delete delivery by order ID.
func (r *txRepo) DeleteByOrderID(ctx context.Context, orderID string) error <span class="cov3" title="2">{
        ct, err := r.tx.Exec(ctx, `DELETE FROM delivery WHERE order_id = $1`, orderID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("delete delivery by order %q: %w", orderID, err)
        }</span>
        <span class="cov3" title="2">if ct.RowsAffected() == 0 </span><span class="cov1" title="1">{
                return fmt.Errorf("delivery for order %q not found", orderID)
        }</span>
        <span class="cov1" title="1">return nil</span>
}

// ReleaseCouriers - release expired couriers.
func (r *DeliveryRepo) ReleaseCouriers(ctx context.Context, now time.Time) (int64, error) <span class="cov1" title="1">{
        cmd, err := r.db.Exec(ctx, `
        UPDATE couriers c
        SET status = $1,
            updated_at = now()
        WHERE c.status = $2
          AND c.id IN (
              SELECT d.courier_id
              FROM delivery d
              WHERE d.deadline &lt; $3
          )
    `, string(domain.StatusAvailable), string(domain.StatusBusy), now)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("release expired couriers: %w", err)
        }</span>
        <span class="cov1" title="1">return cmd.RowsAffected(), nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package repository

import (
        "errors"

        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgconn"
)

// IsDuplicate - signals that the error is a duplicate key violation.
func IsDuplicate(err error) bool <span class="cov6" title="2">{
        var pgerr *pgconn.PgError
        return errors.As(err, &amp;pgerr) &amp;&amp; pgerr.Code == "23505"
}</span>

// IsNotFound - signals that the error is a not found error.
func IsNotFound(err error) bool <span class="cov10" title="3">{
        return errors.Is(err, pgx.ErrNoRows)
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package courier

import (
        "context"
        "strings"
        "time"

        "course-go-avito-Orurh/internal/apperr"
        "course-go-avito-Orurh/internal/domain"
)

// Service coordinates courier business logic and orchestrates repository calls.
type Service struct {
        repo             courierRepository
        operationTimeout time.Duration
}

// NewService creates and configures a courier Service.
func NewService(r courierRepository, timeout time.Duration) *Service <span class="cov10" title="60">{
        if timeout &lt;= 0 </span><span class="cov4" title="4">{
                timeout = 3 * time.Second
        }</span>
        <span class="cov10" title="60">return &amp;Service{repo: r, operationTimeout: timeout}</span>
}

func (s *Service) withTimeout(ctx context.Context) (context.Context, context.CancelFunc) <span class="cov8" title="32">{
        return context.WithTimeout(ctx, s.operationTimeout)
}</span>

func validateCreate(c *domain.Courier) error <span class="cov7" title="16">{
        if c == nil </span><span class="cov2" title="2">{
                return apperr.ErrInvalid
        }</span>
        <span class="cov6" title="14">if strings.TrimSpace(c.Name) == "" </span><span class="cov4" title="4">{
                return apperr.ErrInvalid
        }</span>
        <span class="cov6" title="10">if !domain.ValidatePhone(c.Phone) </span><span class="cov2" title="2">{
                return apperr.ErrInvalid
        }</span>
        <span class="cov5" title="8">if !domain.CourierStatus(c.Status).Valid() </span><span class="cov2" title="2">{
                return apperr.ErrInvalid
        }</span>
        <span class="cov4" title="6">if c.TransportType == "" </span><span class="cov2" title="2">{
                c.TransportType = domain.TransportTypeFoot
        }</span>
        <span class="cov4" title="6">if !domain.CourierTransportType(c.TransportType).Valid() </span><span class="cov2" title="2">{
                return apperr.ErrInvalid
        }</span>
        <span class="cov4" title="4">return nil</span>
}

func validateUpdate(u *domain.PartialCourierUpdate) error <span class="cov8" title="26">{
        if u.ID &lt;= 0 </span><span class="cov4" title="4">{
                return apperr.ErrInvalid
        }</span>
        <span class="cov7" title="22">if u.Name == nil &amp;&amp; u.Phone == nil &amp;&amp; u.Status == nil &amp;&amp; u.TransportType == nil </span><span class="cov2" title="2">{
                return apperr.ErrInvalid
        }</span>
        <span class="cov7" title="20">if u.Name != nil &amp;&amp; strings.TrimSpace(*u.Name) == "" </span><span class="cov2" title="2">{
                return apperr.ErrInvalid
        }</span>
        <span class="cov7" title="18">if u.Phone != nil &amp;&amp; !domain.ValidatePhone(*u.Phone) </span><span class="cov2" title="2">{
                return apperr.ErrInvalid
        }</span>
        <span class="cov7" title="16">if u.Status != nil &amp;&amp; !domain.CourierStatus(*u.Status).Valid() </span><span class="cov2" title="2">{
                return apperr.ErrInvalid
        }</span>
        <span class="cov6" title="14">if u.TransportType != nil &amp;&amp; !domain.CourierTransportType(*u.TransportType).Valid() </span><span class="cov2" title="2">{
                return apperr.ErrInvalid
        }</span>
        <span class="cov6" title="12">return nil</span>
}

// Get retrieves a courier by its ID.
func (s *Service) Get(ctx context.Context, id int64) (*domain.Courier, error) <span class="cov6" title="12">{
        ctx, cancel := s.withTimeout(ctx)
        defer cancel()
        c, err := s.repo.Get(ctx, id)
        if err != nil </span><span class="cov5" title="8">{
                return nil, err
        }</span>
        <span class="cov4" title="4">if c == nil </span><span class="cov2" title="2">{
                return nil, apperr.ErrNotFound
        }</span>
        <span class="cov2" title="2">return c, nil</span>
}

// List returns couriers with optional pagination
func (s *Service) List(ctx context.Context, limit, offset *int) ([]domain.Courier, error) <span class="cov4" title="4">{
        ctx, cancel := s.withTimeout(ctx)
        defer cancel()
        return s.repo.List(ctx, limit, offset)
}</span>

// Create persists a new courier and returns its generated ID.
func (s *Service) Create(ctx context.Context, c *domain.Courier) (int64, error) <span class="cov7" title="16">{
        if err := validateCreate(c); err != nil </span><span class="cov6" title="12">{
                return 0, err
        }</span>
        <span class="cov4" title="4">ctx, cancel := s.withTimeout(ctx)
        defer cancel()
        return s.repo.Create(ctx, c)</span>
}

// UpdatePartial applies a partial update to a courier. It returns true if a row was updated.
func (s *Service) UpdatePartial(ctx context.Context, u domain.PartialCourierUpdate) (bool, error) <span class="cov8" title="26">{
        if err := validateUpdate(&amp;u); err != nil </span><span class="cov6" title="14">{
                return false, err
        }</span>
        <span class="cov6" title="12">ctx, cancel := s.withTimeout(ctx)
        defer cancel()
        ok, err := s.repo.UpdatePartial(ctx, u)
        if err != nil </span><span class="cov2" title="2">{
                return false, err
        }</span>
        <span class="cov6" title="10">if !ok </span><span class="cov2" title="2">{
                return false, apperr.ErrNotFound
        }</span>
        <span class="cov5" title="8">return true, nil</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package delivery

import (
        "fmt"
        "time"

        "course-go-avito-Orurh/internal/domain"
)

type defaultTimeFactory struct{}

// NewTimeFactory - creates a new TimeFactory.
func NewTimeFactory() TimeFactory <span class="cov7" title="4">{
        return defaultTimeFactory{}
}</span>

// Deadline returns the delivery deadline based on the transport type and the current time.
func (defaultTimeFactory) Deadline(transport domain.CourierTransportType, now time.Time) (time.Time, error) <span class="cov10" title="8">{
        switch transport </span>{
        case domain.TransportTypeFoot:<span class="cov4" title="2">
                return now.Add(30 * time.Minute), nil</span>
        case domain.TransportTypeScooter:<span class="cov4" title="2">
                return now.Add(15 * time.Minute), nil</span>
        case domain.TransportTypeCar:<span class="cov4" title="2">
                return now.Add(5 * time.Minute), nil</span>
        default:<span class="cov4" title="2">
                return time.Time{}, fmt.Errorf("unknown transport type: %s", transport)</span>
        }
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package delivery

import (
        "context"
        "strings"
        "time"

        "course-go-avito-Orurh/internal/apperr"
        "course-go-avito-Orurh/internal/domain"
        "course-go-avito-Orurh/internal/logx"
)

// Service - service for assigning deliveries to couriers.
type Service struct {
        repo             deliveryRepository
        factory          TimeFactory
        operationTimeout time.Duration
        logger           logx.Logger
}

func (s *Service) withTimeout(ctx context.Context) (context.Context, context.CancelFunc) <span class="cov10" title="50">{
        return context.WithTimeout(ctx, s.operationTimeout)
}</span>

// NewDeliveryService - creates a new DeliveryService.
func NewDeliveryService(r deliveryRepository, f TimeFactory, timeout time.Duration, logger logx.Logger) *Service <span class="cov9" title="40">{
        if timeout &lt;= 0 </span><span class="cov2" title="2">{
                timeout = 3 * time.Second
        }</span>
        <span class="cov9" title="40">return &amp;Service{
                repo:             r,
                factory:          f,
                operationTimeout: timeout,
                logger:           logger,
        }</span>
}

// Assign assigns a delivery to a courier.
func (s *Service) Assign(ctx context.Context, orderID string) (domain.AssignResult, error) <span class="cov7" title="18">{
        orderID, err := validateOrderID(orderID)
        if err != nil </span><span class="cov2" title="2">{
                return domain.AssignResult{}, err
        }</span>

        <span class="cov7" title="16">ctx, cancel := s.withTimeout(ctx)
        defer cancel()

        var result domain.AssignResult

        err = s.repo.WithTx(ctx, func(tx TxRepository) error </span><span class="cov6" title="12">{
                courier, err := tx.FindAvailableCourierForUpdate(ctx)
                if err != nil </span><span class="cov2" title="2">{
                        return err
                }</span>
                <span class="cov6" title="10">if courier == nil </span><span class="cov2" title="2">{
                        return apperr.ErrConflict
                }</span>

                <span class="cov5" title="8">now := time.Now().UTC()
                deadline, err := s.factory.Deadline(domain.CourierTransportType(courier.TransportType), now)
                if err != nil </span><span class="cov2" title="2">{
                        return err
                }</span>

                <span class="cov5" title="6">d := &amp;domain.Delivery{
                        CourierID:  courier.ID,
                        OrderID:    orderID,
                        AssignedAt: now,
                        Deadline:   deadline,
                }
                if err := tx.InsertDelivery(ctx, d); err != nil </span><span class="cov2" title="2">{
                        return err
                }</span>

                <span class="cov4" title="4">if err := tx.UpdateCourierStatus(ctx, courier.ID, domain.StatusBusy); err != nil </span><span class="cov2" title="2">{
                        return err
                }</span>

                <span class="cov2" title="2">result = domain.AssignResult{
                        CourierID:     courier.ID,
                        OrderID:       orderID,
                        TransportType: courier.TransportType,
                        Deadline:      deadline,
                }

                return nil</span>
        })
        <span class="cov7" title="16">if err != nil </span><span class="cov7" title="14">{
                return domain.AssignResult{}, err
        }</span>

        <span class="cov2" title="2">s.logger.Info("courier assigned",
                logx.String("event", "courier_assigned"),
                logx.String("order_id", result.OrderID),
                logx.Int64("courier_id", result.CourierID),
                logx.String("transport", string(result.TransportType)),
                logx.Time("deadline", result.Deadline),
        )

        return result, nil</span>
}

// Unassign unassigns a delivery from a courier.
func (s *Service) Unassign(ctx context.Context, orderID string) (domain.UnassignResult, error) <span class="cov7" title="14">{
        orderID, err := validateOrderID(orderID)
        if err != nil </span><span class="cov2" title="2">{
                return domain.UnassignResult{}, err
        }</span>

        <span class="cov6" title="12">ctx, cancel := s.withTimeout(ctx)
        defer cancel()

        var result domain.UnassignResult

        err = s.repo.WithTx(ctx, func(tx TxRepository) error </span><span class="cov6" title="10">{
                d, err := tx.GetByOrderID(ctx, orderID)
                if err != nil </span><span class="cov2" title="2">{
                        return err
                }</span>
                <span class="cov5" title="8">if d == nil </span><span class="cov2" title="2">{
                        return apperr.ErrNotFound
                }</span>

                <span class="cov5" title="6">if err := tx.DeleteByOrderID(ctx, orderID); err != nil </span><span class="cov2" title="2">{
                        return err
                }</span>

                <span class="cov4" title="4">if err := tx.UpdateCourierStatus(ctx, d.CourierID, domain.StatusAvailable); err != nil </span><span class="cov2" title="2">{
                        return err
                }</span>

                <span class="cov2" title="2">result = domain.UnassignResult{
                        CourierID: d.CourierID,
                        OrderID:   orderID,
                        Status:    "unassigned",
                }

                return nil</span>
        })
        <span class="cov6" title="12">if err != nil </span><span class="cov6" title="10">{
                return domain.UnassignResult{}, err
        }</span>

        <span class="cov2" title="2">return result, nil</span>
}

func validateOrderID(raw string) (string, error) <span class="cov8" title="32">{
        orderID := strings.TrimSpace(raw)
        if orderID == "" </span><span class="cov4" title="4">{
                return "", apperr.ErrInvalid
        }</span>
        <span class="cov8" title="28">return orderID, nil</span>
}

// ReleaseExpired releases expired couriers.
func (s *Service) ReleaseExpired(ctx context.Context) error <span class="cov8" title="22">{
        ctx, cancel := s.withTimeout(ctx)
        defer cancel()

        now := time.Now().UTC()
        _, err := s.repo.ReleaseCouriers(ctx, now)
        return err
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package orders

import (
        "context"
        "strings"
)

type actionFunc func(context.Context, Event) error

type actionFactory struct {
        byStatus map[string]actionFunc
}

func newActionFactory(onCreated, onCanceled, onCompleted actionFunc) *actionFactory <span class="cov10" title="16">{
        return &amp;actionFactory{
                byStatus: map[string]actionFunc{
                        "created": onCreated,
                        // добавил что бы забрать заказ если курьер освободиться
                        // пока не придумал как правильнее
                        // "pending":    p.onCreated,
                        // "confirmed":  p.onCreated,
                        // "cooking":    p.onCreated,
                        // "delivering": p.onCreated,
                        "canceled":  onCanceled,
                        "deleted":   onCanceled,
                        "completed": onCompleted,
                },
        }
}</span>

func (f *actionFactory) get(status string) (actionFunc, bool) <span class="cov10" title="16">{
        status = strings.ToLower(strings.TrimSpace(status))
        fn, ok := f.byStatus[status]
        return fn, ok
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">package orders

import (
        "context"
        "errors"

        "course-go-avito-Orurh/internal/apperr"
        "course-go-avito-Orurh/internal/domain"
        "course-go-avito-Orurh/internal/repository"
        "course-go-avito-Orurh/internal/service/delivery"
)

// Processor processes orders events
type Processor struct {
        delivery DeliveryPort
        repo     TxRunner
        factory  *actionFactory
}

// NewProcessorWithDeps creates a Processor from interfaces (handy for tests).
func NewProcessorWithDeps(deliverySvc DeliveryPort, repo TxRunner) *Processor <span class="cov10" title="16">{
        return newProcessor(deliverySvc, repo)
}</span>

type repoAdapter struct {
        r *repository.DeliveryRepo
}

// WithTx opens a transaction and executes fn within it.
func (a repoAdapter) WithTx(ctx context.Context, fn func(tx delivery.TxRepository) error) error <span class="cov0" title="0">{
        return a.r.WithTx(ctx, fn)
}</span>

// NewProcessor creates a new orders.Processor
func NewProcessor(deliverySvc *delivery.Service, repo *repository.DeliveryRepo) *Processor <span class="cov0" title="0">{
        return newProcessor(deliverySvc, repoAdapter{r: repo})
}</span>

func newProcessor(deliverySvc DeliveryPort, repo TxRunner) *Processor <span class="cov10" title="16">{
        p := &amp;Processor{
                delivery: deliverySvc,
                repo:     repo,
        }
        p.factory = newActionFactory(p.onCreated, p.onCanceled, p.onCompleted)
        return p
}</span>

// Handle processes a single orders.Event
func (p *Processor) Handle(ctx context.Context, e Event) error <span class="cov10" title="16">{
        if p.factory == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov10" title="16">fn, ok := p.factory.get(e.Status)
        if !ok </span><span class="cov3" title="2">{
                return nil
        }</span>
        <span class="cov9" title="14">return fn(ctx, e)</span>
}

func (p *Processor) onCreated(ctx context.Context, e Event) error <span class="cov6" title="6">{
        _, err := p.delivery.Assign(ctx, e.OrderID)
        if errors.Is(err, apperr.ErrConflict) </span><span class="cov3" title="2">{
                return nil
        }</span>
        <span class="cov5" title="4">return err</span>
}

func (p *Processor) onCanceled(ctx context.Context, e Event) error <span class="cov5" title="4">{
        _, err := p.delivery.Unassign(ctx, e.OrderID)
        if errors.Is(err, apperr.ErrNotFound) </span><span class="cov3" title="2">{
                return nil
        }</span>
        <span class="cov3" title="2">return err</span>
}

func (p *Processor) onCompleted(ctx context.Context, e Event) error <span class="cov5" title="4">{
        return p.repo.WithTx(ctx, func(tx delivery.TxRepository) error </span><span class="cov5" title="4">{
                d, err := tx.GetByOrderID(ctx, e.OrderID)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov5" title="4">if d == nil </span><span class="cov3" title="2">{
                        return nil
                }</span>
                <span class="cov3" title="2">return tx.UpdateCourierStatus(ctx, d.CourierID, domain.StatusAvailable)</span>
        })
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package testlog

import (
        "sync"

        "course-go-avito-Orurh/internal/logx"
)

type Entry struct {
        Level  string
        Msg    string
        Fields []logx.Field
}

type Recorder struct {
        mu      sync.Mutex
        entries []Entry
}

func New() *Recorder <span class="cov9" title="16">{ return &amp;Recorder{} }</span>

func (r *Recorder) Logger() logx.Logger <span class="cov10" title="20">{
        return bound{r: r}
}</span>

func (r *Recorder) Entries() []Entry <span class="cov7" title="10">{
        r.mu.Lock()
        defer r.mu.Unlock()
        out := make([]Entry, len(r.entries))
        copy(out, r.entries)
        return out
}</span>

func (r *Recorder) add(level, msg string, fields []logx.Field) <span class="cov7" title="10">{
        r.mu.Lock()
        defer r.mu.Unlock()
        cp := append([]logx.Field(nil), fields...)
        r.entries = append(r.entries, Entry{Level: level, Msg: msg, Fields: cp})
}</span>

type bound struct {
        r    *Recorder
        base []logx.Field
}

func (b bound) Debug(msg string, f ...logx.Field) <span class="cov0" title="0">{
        b.r.add("debug", msg, append(b.base, f...))
}</span>

func (b bound) Info(msg string, f ...logx.Field) <span class="cov5" title="4">{
        b.r.add("info", msg, append(b.base, f...))
}</span>

func (b bound) Warn(msg string, f ...logx.Field) <span class="cov5" title="4">{
        b.r.add("warn", msg, append(b.base, f...))
}</span>

func (b bound) Error(msg string, f ...logx.Field) <span class="cov3" title="2">{
        b.r.add("error", msg, append(b.base, f...))
}</span>

func (b bound) With(f ...logx.Field) logx.Logger <span class="cov0" title="0">{
        nb := bound{r: b.r, base: append([]logx.Field(nil), b.base...)}
        nb.base = append(nb.base, f...)
        return nb
}</span>

func (b bound) Sync() error <span class="cov0" title="0">{ return nil }</span>

var _ logx.Logger = bound{}
</pre>
		
		<pre class="file" id="file33" style="display: none">package kafka

import (
        "context"
        "encoding/json"
        "strings"
        "time"

        "course-go-avito-Orurh/internal/logx"
        "course-go-avito-Orurh/internal/service/orders"

        "github.com/IBM/sarama"
)

// HandleFunc processes a single orders.Event from Kafka
type HandleFunc func(context.Context, orders.Event) error

// Consumer wraps a Sarama consumer group and dispatches events to a handler
type Consumer struct {
        group   sarama.ConsumerGroup
        topic   string
        handler HandleFunc
        logger  logx.Logger
}

var newConsumerGroup = sarama.NewConsumerGroup

// NewConsumer creates a new Kafka consumer
func NewConsumer(logger logx.Logger, brokers []string, groupID, topic string, h HandleFunc) (*Consumer, error) <span class="cov7" title="8">{
        // не стратую если у кафки нет настроек
        if len(brokers) == 0 || strings.TrimSpace(topic) == "" || strings.TrimSpace(groupID) == "" </span><span class="cov6" title="6">{
                return nil, nil
        }</span>

        <span class="cov3" title="2">cfg := sarama.NewConfig()
        cfg.Consumer.Offsets.Initial = sarama.OffsetOldest

        group, err := newConsumerGroup(brokers, groupID, cfg)
        if err != nil </span><span class="cov3" title="2">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;Consumer{
                group:   group,
                topic:   topic,
                handler: h,
                logger:  logger,
        }, nil</span>
}

// Run starts the consumer
func (c *Consumer) Run(ctx context.Context) error <span class="cov0" title="0">{
        if c == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        // я подумал логировать ошибки кафки в отдельной горутине...
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>
                        case err, ok := &lt;-c.group.Errors():<span class="cov0" title="0">
                                if !ok </span><span class="cov0" title="0">{
                                        return
                                }</span>
                                <span class="cov0" title="0">c.logger.Error("kafka consumer group error", logx.Any("err", err))</span>
                        }
                }
        }()

        <span class="cov0" title="0">h := &amp;groupHandler{c: c}

        for </span><span class="cov0" title="0">{
                if err := c.group.Consume(ctx, []string{c.topic}, h); err != nil </span><span class="cov0" title="0">{
                        if ctx.Err() != nil </span><span class="cov0" title="0">{
                                return ctx.Err()
                        }</span>
                        <span class="cov0" title="0">c.logger.Error("kafka consume error", logx.Any("err", err))
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return ctx.Err()</span>
                        case &lt;-time.After(time.Second):<span class="cov0" title="0"></span>
                        }
                        <span class="cov0" title="0">continue</span>
                }
                <span class="cov0" title="0">if ctx.Err() != nil </span><span class="cov0" title="0">{
                        return ctx.Err()
                }</span>
        }
}

func (c *Consumer) Close() error <span class="cov0" title="0">{
        if c == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return c.group.Close()</span>
}

type groupHandler struct{ c *Consumer }

func (h *groupHandler) Setup(sarama.ConsumerGroupSession) error <span class="cov0" title="0">{
        return nil
}</span>

func (h *groupHandler) Cleanup(sarama.ConsumerGroupSession) error <span class="cov0" title="0">{
        return nil
}</span>

func (h *groupHandler) ConsumeClaim(sess sarama.ConsumerGroupSession, claim sarama.ConsumerGroupClaim) error <span class="cov7" title="8">{
        for </span><span class="cov10" title="16">{
                select </span>{
                case &lt;-sess.Context().Done():<span class="cov0" title="0">
                        return nil</span>
                case msg, ok := &lt;-claim.Messages():<span class="cov10" title="16">
                        if !ok </span><span class="cov7" title="8">{
                                return nil
                        }</span>

                        <span class="cov7" title="8">var dto EventDTO
                        if err := json.Unmarshal(msg.Value, &amp;dto); err != nil </span><span class="cov3" title="2">{
                                h.c.logger.Warn("kafka bad json", logx.Any("err", err))
                                sess.MarkMessage(msg, "")
                                continue</span>
                        }

                        <span class="cov6" title="6">ev := ToDomain(dto)

                        if ev.OrderID == "" </span><span class="cov3" title="2">{
                                h.c.logger.Warn("kafka empty order_id")
                                sess.MarkMessage(msg, "")
                                continue</span>
                        }

                        <span class="cov5" title="4">if err := h.c.handler(sess.Context(), ev); err != nil </span><span class="cov3" title="2">{
                                h.c.logger.Error("kafka handle failed, skipping message",
                                        logx.String("order_id", ev.OrderID),
                                        logx.String("status", ev.Status),
                                        logx.Any("err", err),
                                )
                                sess.MarkMessage(msg, "")
                                continue</span>
                        }
                        <span class="cov3" title="2">sess.MarkMessage(msg, "")</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package kafka

import (
        "strings"
        "time"

        "course-go-avito-Orurh/internal/service/orders"
)

// EventDTO is a data transfer object for orders.Event
type EventDTO struct {
        OrderID   string    `json:"order_id"`
        Status    string    `json:"status"`
        CreatedAt time.Time `json:"created_at"`
}

// ToDomain converts EventDTO to orders.Event
func ToDomain(dto EventDTO) orders.Event <span class="cov10" title="8">{
        return orders.Event{
                OrderID:   strings.TrimSpace(dto.OrderID),
                Status:    strings.TrimSpace(dto.Status),
                CreatedAt: dto.CreatedAt,
        }
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
